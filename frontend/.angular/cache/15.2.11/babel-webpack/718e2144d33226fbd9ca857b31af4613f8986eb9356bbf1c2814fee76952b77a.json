{"ast":null,"code":"export function appInitializer(accountService) {\n  return () => new Promise(resolve => {\n    console.log('App Initializer: Attempting to refresh token...');\n    accountService.refreshToken().subscribe({\n      next: user => {\n        // This 'user' would be the user object if refreshToken() in AccountService\n        // returns it after a successful refresh. If it returns of(null) or void,\n        // this might be null or not hit if it completes without emitting.\n        if (user) {\n          // Check if user data was actually returned/updated\n          console.log('App Initializer: Token refresh successful or existing session validated.');\n        } else {\n          console.log('App Initializer: No active session to refresh, or refresh call completed without new user data.');\n        }\n        // No specific action needed on next if AccountService updates its own state.\n      },\n\n      error: err => {\n        var _a;\n        // This will catch errors like the 401/400 from your FakeBackendInterceptor\n        // if the refresh token is missing or invalid.\n        const errorMessage = ((_a = err === null || err === void 0 ? void 0 : err.error) === null || _a === void 0 ? void 0 : _a.message) || (err === null || err === void 0 ? void 0 : err.message) || 'Unknown error during token refresh.';\n        console.warn(`App Initializer: Failed to refresh token or no active session. Reason: ${errorMessage}`);\n        // The app should still start, the user will just not be logged in.\n        // Route guards will handle redirection if needed.\n      },\n\n      complete: () => {\n        // This is hit if the observable completes successfully (e.g., of(null) from AccountService).\n        console.log('App Initializer: Refresh token attempt completed.');\n        resolve(); // Resolve the promise here, after completion or error\n      }\n    });\n    // Removed .add(() => resolve()) because resolve is now handled in complete/error.\n    // However, if refreshToken() could complete *without* hitting next/error/complete\n    // (e.g. if it uses take(1) on a subject that doesn't emit, which is unlikely for an HTTP call),\n    // then .add() is safer. For typical HttpClient observables, complete will be called.\n    // To be absolutely safe with various observable types, you can keep .add():\n    // const subscription = accountService.refreshToken().subscribe({...});\n    // subscription.add(() => resolve());\n  });\n}","map":{"version":3,"mappings":"AAEA,OAAM,SAAUA,cAAc,CAACC,cAA8B;EACzD,OAAO,MAAM,IAAIC,OAAO,CAAQC,OAAO,IAAI;IACvCC,OAAO,CAACC,GAAG,CAAC,iDAAiD,CAAC;IAE9DJ,cAAc,CAACK,YAAY,EAAE,CAACC,SAAS,CAAC;MACpCC,IAAI,EAAGC,IAAI,IAAI;QACX;QACA;QACA;QACA,IAAIA,IAAI,EAAE;UAAE;UACRL,OAAO,CAACC,GAAG,CAAC,0EAA0E,CAAC;SAC1F,MAAM;UACHD,OAAO,CAACC,GAAG,CAAC,iGAAiG,CAAC;;QAElH;MACJ,CAAC;;MACDK,KAAK,EAAGC,GAAG,IAAI;;QACX;QACA;QACA,MAAMC,YAAY,GAAG,UAAG,aAAHD,GAAG,uBAAHA,GAAG,CAAED,KAAK,0CAAEG,OAAO,MAAIF,GAAG,aAAHA,GAAG,uBAAHA,GAAG,CAAEE,OAAO,KAAI,qCAAqC;QACjGT,OAAO,CAACU,IAAI,CAAC,0EAA0EF,YAAY,EAAE,CAAC;QACtG;QACA;MACJ,CAAC;;MACDG,QAAQ,EAAE,MAAK;QACX;QACAX,OAAO,CAACC,GAAG,CAAC,mDAAmD,CAAC;QAChEF,OAAO,EAAE,CAAC,CAAC;MACf;KACH,CAAC;IACF;IACA;IACA;IACA;IACA;IACA;IACA;EACJ,CAAC,CAAC;AACN","names":["appInitializer","accountService","Promise","resolve","console","log","refreshToken","subscribe","next","user","error","err","errorMessage","message","warn","complete"],"sourceRoot":"","sources":["E:\\semifinals\\groupB-fullstack-app\\frontend\\src\\app\\_helpers\\app.initializer.ts"],"sourcesContent":["import { AccountService } from '@app/_services';\r\n\r\nexport function appInitializer(accountService: AccountService) {\r\n    return () => new Promise<void>((resolve) => { // Using Promise<void> as it doesn't return a value\r\n        console.log('App Initializer: Attempting to refresh token...');\r\n\r\n        accountService.refreshToken().subscribe({\r\n            next: (user) => {\r\n                // This 'user' would be the user object if refreshToken() in AccountService\r\n                // returns it after a successful refresh. If it returns of(null) or void,\r\n                // this might be null or not hit if it completes without emitting.\r\n                if (user) { // Check if user data was actually returned/updated\r\n                    console.log('App Initializer: Token refresh successful or existing session validated.');\r\n                } else {\r\n                    console.log('App Initializer: No active session to refresh, or refresh call completed without new user data.');\r\n                }\r\n                // No specific action needed on next if AccountService updates its own state.\r\n            },\r\n            error: (err) => {\r\n                // This will catch errors like the 401/400 from your FakeBackendInterceptor\r\n                // if the refresh token is missing or invalid.\r\n                const errorMessage = err?.error?.message || err?.message || 'Unknown error during token refresh.';\r\n                console.warn(`App Initializer: Failed to refresh token or no active session. Reason: ${errorMessage}`);\r\n                // The app should still start, the user will just not be logged in.\r\n                // Route guards will handle redirection if needed.\r\n            },\r\n            complete: () => {\r\n                // This is hit if the observable completes successfully (e.g., of(null) from AccountService).\r\n                console.log('App Initializer: Refresh token attempt completed.');\r\n                resolve(); // Resolve the promise here, after completion or error\r\n            }\r\n        });\r\n        // Removed .add(() => resolve()) because resolve is now handled in complete/error.\r\n        // However, if refreshToken() could complete *without* hitting next/error/complete\r\n        // (e.g. if it uses take(1) on a subject that doesn't emit, which is unlikely for an HTTP call),\r\n        // then .add() is safer. For typical HttpClient observables, complete will be called.\r\n        // To be absolutely safe with various observable types, you can keep .add():\r\n        // const subscription = accountService.refreshToken().subscribe({...});\r\n        // subscription.add(() => resolve());\r\n    });\r\n}"]},"metadata":{},"sourceType":"module","externalDependencies":[]}