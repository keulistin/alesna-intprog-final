{"ast":null,"code":"import { HttpResponse, HTTP_INTERCEPTORS, HttpErrorResponse } from '@angular/common/http';\nimport { of, throwError } from 'rxjs';\nimport { delay, mergeMap, materialize, dematerialize } from 'rxjs/operators';\nimport { Role } from '@app/_models'; // Assuming this path is correct\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@app/_services\";\n// Key for localStorage\nconst accountsKey = 'app-hr-tool-accounts'; // Made key more specific\nexport let FakeBackendInterceptor = /*#__PURE__*/(() => {\n  class FakeBackendInterceptor {\n    constructor(alertService) {\n      this.alertService = alertService;\n      // In-memory for other entities\n      this.employees = [{\n        id: 1,\n        employeeId: 'EMP001',\n        userId: 1,\n        position: 'Developer',\n        departmentId: 1,\n        hireDate: '2025-01-01',\n        status: 'Active'\n      }, {\n        id: 2,\n        employeeId: 'EMP002',\n        userId: 2,\n        position: 'Designer',\n        departmentId: 2,\n        hireDate: '2025-02-01',\n        status: 'Active'\n      }];\n      this.departments = [{\n        id: 1,\n        name: 'Engineering',\n        description: 'Software development team',\n        employeeCount: 1\n      }, {\n        id: 2,\n        name: 'Marketing',\n        description: 'Marketing team',\n        employeeCount: 1\n      }];\n      this.workflows = [{\n        id: 1,\n        employeeId: 1,\n        type: 'Onboarding',\n        details: {\n          task: 'Setup workstation'\n        },\n        status: 'Pending'\n      }];\n      this.appRequests = [{\n        id: 1,\n        employeeId: 2,\n        type: 'Equipment',\n        requestItems: [{\n          name: 'Laptop',\n          quantity: 1\n        }],\n        status: 'Pending'\n      }];\n      // ID Generators for in-memory entities\n      this.nextEmployeeId = this.employees.length > 0 ? Math.max(0, ...this.employees.map(e => e.id)) + 1 : 1;\n      this.nextDepartmentId = this.departments.length > 0 ? Math.max(0, ...this.departments.map(d => d.id)) + 1 : 1;\n      this.nextWorkflowId = this.workflows.length > 0 ? Math.max(0, ...this.workflows.map(w => w.id)) + 1 : 1;\n      this.nextAppRequestId = this.appRequests.length > 0 ? Math.max(0, ...this.appRequests.map(r => r.id)) + 1 : 1;\n      this.accounts = JSON.parse(localStorage.getItem(accountsKey)) || [];\n      // Ensure default admin/user if local storage is empty or new\n      if (this.accounts.length === 0) {\n        this.accounts.push({\n          id: 1,\n          email: 'admin@example.com',\n          password: 'admin',\n          role: Role.Admin,\n          employeeId: 1,\n          isVerified: true,\n          status: 'Active',\n          refreshTokens: [],\n          dateCreated: new Date().toISOString(),\n          firstName: 'Admin',\n          lastName: 'User'\n        });\n        this.accounts.push({\n          id: 2,\n          email: 'user@example.com',\n          password: 'user',\n          role: Role.User,\n          employeeId: 2,\n          isVerified: true,\n          status: 'Active',\n          refreshTokens: [],\n          dateCreated: new Date().toISOString(),\n          firstName: 'Normal',\n          lastName: 'User'\n        });\n        this.saveAccounts();\n      }\n    }\n    intercept(request, next) {\n      const {\n        url,\n        method,\n        headers,\n        body\n      } = request;\n      return of(null).pipe(mergeMap(() => this.handleRoute(url, method, headers, body, next))).pipe(materialize()).pipe(delay(500)).pipe(dematerialize());\n    }\n    handleRoute(url, method, headers, body, next) {\n      // --- ACCOUNT MANAGEMENT ROUTES ---\n      switch (true) {\n        case url.endsWith('/accounts/authenticate') && method === 'POST':\n          return this.authenticate(body, headers);\n        case url.endsWith('/accounts/refresh-token') && method === 'POST':\n          return this.refreshToken(body, headers);\n        case url.endsWith('/accounts/revoke-token') && method === 'POST':\n          return this.revokeToken(body, headers);\n        case url.endsWith('/accounts/register') && method === 'POST':\n          return this.register(body);\n        case url.endsWith('/accounts/verify-email') && method === 'POST':\n          return this.verifyEmail(body);\n        case url.endsWith('/accounts/forgot-password') && method === 'POST':\n          return this.forgotPassword(body);\n        case url.endsWith('/accounts/validate-reset-token') && method === 'POST':\n          return this.validateResetToken(body);\n        case url.endsWith('/accounts/reset-password') && method === 'POST':\n          return this.resetPassword(body);\n        case url.endsWith('/accounts') && method === 'GET':\n          return this.getAccounts(headers);\n        case url.match(/\\/accounts\\/(\\d+)$/) && method === 'GET':\n          return this.getAccountById(this.idFromUrl(url), headers);\n        case url.endsWith('/accounts') && method === 'POST':\n          return this.createAccount(body, headers);\n        case url.match(/\\/accounts\\/(\\d+)$/) && method === 'PUT':\n          return this.updateAccount(this.idFromUrl(url), body, headers);\n        case url.match(/\\/accounts\\/(\\d+)$/) && method === 'DELETE':\n          return this.deleteAccount(this.idFromUrl(url), headers);\n        // --- OTHER ENTITY ROUTES ---\n        // Employees\n        case url.endsWith('/employees') && method === 'GET':\n          return this.authorize(headers, null, () => this.ok(this.employees));\n        case url.endsWith('/employees') && method === 'POST':\n          return this.authorize(headers, Role.Admin, () => {\n            const newEmployee = Object.assign({\n              id: this.nextEmployeeId++\n            }, body);\n            this.employees.push(newEmployee);\n            const dept = this.departments.find(d => d.id === newEmployee.departmentId);\n            if (dept) dept.employeeCount++;\n            return this.ok(newEmployee, 201);\n          });\n        case url.match(/\\/employees\\/(\\d+)$/) && method === 'GET':\n          {\n            const id = this.idFromUrl(url);\n            return this.authorize(headers, null, () => {\n              const employee = this.employees.find(e => e.id === id);\n              return employee ? this.ok(employee) : this.error('Employee not found', 404);\n            });\n          }\n        case url.match(/\\/employees\\/(\\d+)$/) && method === 'PUT':\n          {\n            const id = this.idFromUrl(url);\n            return this.authorize(headers, Role.Admin, () => {\n              const employeeIndex = this.employees.findIndex(e => e.id === id);\n              if (employeeIndex === -1) return this.error('Employee not found', 404);\n              const oldEmployeeData = this.employees[employeeIndex];\n              const updatedEmployee = Object.assign(Object.assign(Object.assign({}, oldEmployeeData), body), {\n                id\n              });\n              if (oldEmployeeData.departmentId !== updatedEmployee.departmentId) {\n                const oldDept = this.departments.find(d => d.id === oldEmployeeData.departmentId);\n                if (oldDept) oldDept.employeeCount = Math.max(0, oldDept.employeeCount - 1);\n                const newDept = this.departments.find(d => d.id === updatedEmployee.departmentId);\n                if (newDept) newDept.employeeCount++;else return this.error('Target department not found', 400);\n              }\n              this.employees[employeeIndex] = updatedEmployee;\n              return this.ok(this.employees[employeeIndex]);\n            });\n          }\n        case url.match(/\\/employees\\/(\\d+)$/) && method === 'DELETE':\n          {\n            const id = this.idFromUrl(url);\n            return this.authorize(headers, Role.Admin, () => {\n              const employeeIndex = this.employees.findIndex(e => e.id === id);\n              if (employeeIndex === -1) return this.error('Employee not found', 404);\n              const deletedEmployee = this.employees.splice(employeeIndex, 1)[0];\n              if (deletedEmployee) {\n                const dept = this.departments.find(d => d.id === deletedEmployee.departmentId);\n                if (dept) dept.employeeCount = Math.max(0, dept.employeeCount - 1);\n              }\n              return this.ok({\n                message: 'Employee deleted'\n              });\n            });\n          }\n        case url.match(/\\/employees\\/(\\d+)\\/transfer$/) && method === 'POST':\n          {\n            const idMatch = url.match(/\\/employees\\/(\\d+)\\/transfer$/);\n            if (!idMatch) return this.error('Invalid URL for employee transfer', 400);\n            const id = parseInt(idMatch[1]);\n            return this.authorize(headers, Role.Admin, () => {\n              const employee = this.employees.find(e => e.id === id);\n              if (!employee) return this.error('Employee not found', 404);\n              const oldDepartmentId = employee.departmentId;\n              const newDepartmentId = body.departmentId;\n              if (oldDepartmentId !== newDepartmentId) {\n                const oldDept = this.departments.find(d => d.id === oldDepartmentId);\n                if (oldDept) oldDept.employeeCount = Math.max(0, oldDept.employeeCount - 1);\n                const newDept = this.departments.find(d => d.id === newDepartmentId);\n                if (newDept) newDept.employeeCount++;else return this.error('Target department not found', 400);\n              }\n              employee.departmentId = newDepartmentId;\n              this.workflows.push({\n                id: this.nextWorkflowId++,\n                employeeId: id,\n                type: 'Transfer',\n                details: body,\n                status: 'Pending'\n              });\n              return this.ok({\n                message: 'Employee transferred successfully',\n                employee\n              });\n            });\n          }\n        // Departments\n        case url.endsWith('/departments') && method === 'GET':\n          return this.authorize(headers, null, () => this.ok(this.departments));\n        case url.endsWith('/departments') && method === 'POST':\n          return this.authorize(headers, Role.Admin, () => {\n            const newDepartment = Object.assign(Object.assign({\n              id: this.nextDepartmentId++\n            }, body), {\n              employeeCount: 0\n            });\n            this.departments.push(newDepartment);\n            return this.ok(newDepartment, 201);\n          });\n        case url.match(/\\/departments\\/(\\d+)$/) && method === 'PUT':\n          {\n            const id = this.idFromUrl(url);\n            return this.authorize(headers, Role.Admin, () => {\n              const deptIndex = this.departments.findIndex(d => d.id === id);\n              if (deptIndex === -1) return this.error('Department not found', 404);\n              this.departments[deptIndex] = Object.assign(Object.assign(Object.assign({}, this.departments[deptIndex]), body), {\n                id\n              });\n              return this.ok(this.departments[deptIndex]);\n            });\n          }\n        case url.match(/\\/departments\\/(\\d+)$/) && method === 'DELETE':\n          {\n            const id = this.idFromUrl(url);\n            return this.authorize(headers, Role.Admin, () => {\n              const dept = this.departments.find(d => d.id === id);\n              if (!dept) return this.error('Department not found', 404);\n              if (dept.employeeCount > 0) return this.error('Cannot delete department with active employees.', 400);\n              this.departments = this.departments.filter(d => d.id !== id);\n              return this.ok({\n                message: 'Department deleted'\n              });\n            });\n          }\n        // Workflows\n        case url.match(/\\/workflows\\/employee\\/(\\d+)$/) && method === 'GET':\n          {\n            const idMatch = url.match(/\\/workflows\\/employee\\/(\\d+)$/);\n            if (!idMatch) return this.error('Invalid URL for employee workflows', 400);\n            const employeeId = parseInt(idMatch[1]);\n            return this.authorize(headers, null, () => {\n              const workflows = this.workflows.filter(w => w.employeeId === employeeId);\n              return this.ok(workflows);\n            });\n          }\n        case url.endsWith('/workflows') && method === 'POST':\n          return this.authorize(headers, Role.Admin, () => {\n            const newWorkflow = Object.assign({\n              id: this.nextWorkflowId++\n            }, body);\n            this.workflows.push(newWorkflow);\n            return this.ok(newWorkflow, 201);\n          });\n        // AppRequests\n        case url.endsWith('/requests') && method === 'GET':\n          return this.authorize(headers, null, () => {\n            const currentAcc = this.currentAccount(headers);\n            if (!currentAcc) return this.unauthorized();\n            if (currentAcc.role === Role.Admin) return this.ok(this.appRequests);\n            const userRequests = this.appRequests.filter(r => {\n              const emp = this.employees.find(e => e.id === r.employeeId);\n              return emp && emp.userId === currentAcc.id;\n            });\n            return this.ok(userRequests);\n          });\n        case url.endsWith('/requests') && method === 'POST':\n          return this.authorize(headers, null, () => {\n            const currentAcc = this.currentAccount(headers);\n            if (!currentAcc || !currentAcc.employeeId) return this.error(\"User not linked to an employee or not authenticated.\", 400);\n            const newRequest = Object.assign(Object.assign({\n              id: this.nextAppRequestId++,\n              employeeId: currentAcc.employeeId\n            }, body), {\n              status: 'Pending'\n            });\n            this.appRequests.push(newRequest);\n            return this.ok(newRequest, 201);\n          });\n        default:\n          // return next.handle(request); // If you have a real backend\n          return throwError(() => new HttpErrorResponse({\n            status: 404,\n            error: {\n              message: `Fake backend: Route not found for ${method} ${url}`\n            }\n          }));\n      }\n    }\n    // --- ACCOUNT MANAGEMENT METHODS ---\n    authenticate(body, headers) {\n      const {\n        email,\n        password\n      } = body;\n      const account = this.accounts.find(x => x.email === email);\n      if (!account) return this.error('Invalid email or password.', 400); // Generic message\n      if (!account.isVerified) {\n        setTimeout(() => {\n          const verifyUrl = `${location.origin}/account/verify-email?token=${account.verificationToken}`;\n          this.alertService.info(`<h4>Verification Email</h4><p>Please click the link to verify: <a href=\"${verifyUrl}\">${verifyUrl}</a></p>`, {\n            autoClose: false\n          });\n        }, 1000);\n        return this.error('Email is not yet verified. Please check your inbox.', 400);\n      }\n      if (account.password !== password) return this.error('Invalid email or password.', 400); // Generic message\n      if (account.status !== 'Active') return this.error('Account is inactive. Please contact support.', 400);\n      account.refreshTokens = account.refreshTokens || [];\n      account.refreshTokens.push(this.generateRefreshTokenForCookie());\n      this.saveAccounts();\n      const accountDetails = this.basicDetails(account);\n      return this.ok(Object.assign(Object.assign({}, accountDetails), {\n        jwtToken: this.generateJwtToken(account)\n      }));\n    }\n    refreshToken(body, headers) {\n      const requestRefreshTokenFromBody = body.refreshToken;\n      const requestRefreshTokenFromCookie = this.getRefreshTokenFromCookie();\n      const requestRefreshToken = requestRefreshTokenFromBody || requestRefreshTokenFromCookie;\n      if (!requestRefreshToken) return this.unauthorized('Refresh token missing.');\n      const account = this.accounts.find(x => x.refreshTokens && x.refreshTokens.includes(requestRefreshToken));\n      if (!account) return this.unauthorized('Invalid or expired refresh token.');\n      account.refreshTokens = account.refreshTokens.filter(x => x !== requestRefreshToken); // Remove old\n      account.refreshTokens.push(this.generateRefreshTokenForCookie()); // Add new (rotation)\n      this.saveAccounts();\n      return this.ok(Object.assign(Object.assign({}, this.basicDetails(account)), {\n        jwtToken: this.generateJwtToken(account)\n      }));\n    }\n    revokeToken(body, headers) {\n      const currentAcc = this.currentAccount(headers);\n      if (!currentAcc) return this.unauthorized();\n      const tokenToRevoke = body.token || this.getRefreshTokenFromCookie(); // Token from body or current cookie\n      const account = this.accounts.find(x => x.id === currentAcc.id);\n      if (account && account.refreshTokens && tokenToRevoke) {\n        account.refreshTokens = account.refreshTokens.filter(x => x !== tokenToRevoke);\n        this.saveAccounts();\n      }\n      // Clear cookie if it was the one revoked\n      if (tokenToRevoke && tokenToRevoke === this.getRefreshTokenFromCookie()) {\n        this.clearRefreshTokenCookie();\n      }\n      return this.ok({\n        message: 'Token revoked successfully.'\n      });\n    }\n    register(body) {\n      const newAccountData = body; // Use Partial for incoming data\n      if (!newAccountData.email || !newAccountData.password) {\n        return this.error('Email and password are required.', 400);\n      }\n      if (this.accounts.find(x => x.email === newAccountData.email)) {\n        setTimeout(() => this.alertService.error(`Email '${newAccountData.email}' is already registered.`), 1000);\n        return this.error(`Email '${newAccountData.email}' is already registered.`, 400);\n      }\n      const newAccount = {\n        id: this.newAccountId(),\n        email: newAccountData.email,\n        password: newAccountData.password,\n        role: this.accounts.length === 0 ? Role.Admin : Role.User,\n        firstName: newAccountData.firstName || '',\n        lastName: newAccountData.lastName || '',\n        title: newAccountData.title || '',\n        status: this.accounts.length === 0 ? 'Active' : 'Inactive',\n        dateCreated: new Date().toISOString(),\n        verificationToken: `${Date.now()}-${Math.random().toString(36).substring(2, 10)}`,\n        isVerified: this.accounts.length === 0,\n        refreshTokens: []\n      };\n      this.accounts.push(newAccount);\n      this.saveAccounts();\n      if (!newAccount.isVerified) {\n        setTimeout(() => {\n          const verifyUrl = `${location.origin}/account/verify-email?token=${newAccount.verificationToken}`;\n          this.alertService.info(`<h4>Verification Email</h4><p>Thanks for registering! Please click the link to verify your email: <a href=\"${verifyUrl}\">${verifyUrl}</a></p><div><strong>NOTE:</strong> This is a fake email.</div>`, {\n            autoClose: false\n          });\n        }, 1000);\n      }\n      return this.ok({\n        message: 'Registration successful. Please check your email to verify your account if required.'\n      }, 201);\n    }\n    verifyEmail(body) {\n      const {\n        token\n      } = body;\n      if (!token) return this.error('Verification token is required.', 400);\n      const account = this.accounts.find(x => x.verificationToken === token);\n      if (!account) return this.error('Verification failed. Invalid or expired token.', 400);\n      if (account.isVerified) return this.ok({\n        message: 'Email already verified.'\n      });\n      account.isVerified = true;\n      account.status = 'Active';\n      delete account.verificationToken;\n      this.saveAccounts();\n      return this.ok({\n        message: 'Email verified successfully. You can now login.'\n      });\n    }\n    forgotPassword(body) {\n      const {\n        email\n      } = body;\n      if (!email) return this.error('Email is required.', 400);\n      const account = this.accounts.find(x => x.email === email);\n      if (account) {\n        account.resetToken = `${Date.now()}-${Math.random().toString(36).substring(2, 10)}`;\n        account.resetTokenExpires = new Date(Date.now() + 24 * 60 * 60 * 1000); // Expires in 24 hours\n        this.saveAccounts();\n        setTimeout(() => {\n          const resetUrl = `${location.origin}/account/reset-password?token=${account.resetToken}`;\n          this.alertService.info(`<h4>Reset Password Email</h4><p>Please click the link to reset your password: <a href=\"${resetUrl}\">${resetUrl}</a></p><p>The link will be valid for 24 hours.</p><div><strong>NOTE:</strong> This is a fake email.</div>`, {\n            autoClose: false\n          });\n        }, 1000);\n      }\n      // Always return OK to prevent email enumeration\n      return this.ok({\n        message: 'If your email address is registered, you will receive a password reset link.'\n      });\n    }\n    validateResetToken(body) {\n      const {\n        token\n      } = body;\n      if (!token) return this.error('Reset token is required.', 400);\n      const account = this.accounts.find(x => x.resetToken === token && x.resetTokenExpires && new Date(x.resetTokenExpires) > new Date());\n      return account ? this.ok({\n        message: 'Token is valid.'\n      }) : this.error('Invalid or expired reset token.', 400);\n    }\n    resetPassword(body) {\n      const {\n        token,\n        password\n      } = body;\n      if (!token || !password) return this.error('Token and new password are required.', 400);\n      const account = this.accounts.find(x => x.resetToken === token && x.resetTokenExpires && new Date(x.resetTokenExpires) > new Date());\n      if (!account) return this.error('Invalid or expired reset token.', 400);\n      account.password = password; // In a real app, hash this\n      account.isVerified = true; // Good to ensure\n      account.status = 'Active';\n      delete account.resetToken;\n      delete account.resetTokenExpires;\n      this.saveAccounts();\n      return this.ok({\n        message: 'Password has been reset successfully. You can now login.'\n      });\n    }\n    getAccounts(headers) {\n      return this.authorize(headers, Role.Admin, () => {\n        return this.ok(this.accounts.map(acc => this.basicDetails(acc)));\n      });\n    }\n    getAccountById(id, headers) {\n      const currentAcc = this.currentAccount(headers);\n      if (!currentAcc) return this.unauthorized();\n      const account = this.accounts.find(x => x.id === id);\n      if (!account) return this.error('Account not found', 404);\n      if (currentAcc.role !== Role.Admin && currentAcc.id !== account.id) {\n        return this.unauthorized(\"You are not authorized to view this account.\");\n      }\n      return this.ok(this.basicDetails(account));\n    }\n    createAccount(body, headers) {\n      return this.authorize(headers, Role.Admin, () => {\n        const newAccountData = body;\n        if (!newAccountData.email || !newAccountData.password || !newAccountData.role) {\n          return this.error('Email, password, and role are required for new account creation.', 400);\n        }\n        if (this.accounts.find(x => x.email === newAccountData.email)) {\n          return this.error(`Email '${newAccountData.email}' is already registered`, 400);\n        }\n        const newAccount = {\n          id: this.newAccountId(),\n          email: newAccountData.email,\n          password: newAccountData.password,\n          role: newAccountData.role,\n          firstName: newAccountData.firstName || '',\n          lastName: newAccountData.lastName || '',\n          title: newAccountData.title || '',\n          dateCreated: new Date().toISOString(),\n          isVerified: true,\n          status: 'Active',\n          refreshTokens: [],\n          employeeId: newAccountData.employeeId // Optional\n        };\n\n        this.accounts.push(newAccount);\n        this.saveAccounts();\n        return this.ok(this.basicDetails(newAccount), 201);\n      });\n    }\n    updateAccount(id, body, headers) {\n      const currentAcc = this.currentAccount(headers);\n      if (!currentAcc) return this.unauthorized();\n      const accountIndex = this.accounts.findIndex(x => x.id === id);\n      if (accountIndex === -1) return this.error('Account not found', 404);\n      const accountToUpdate = this.accounts[accountIndex];\n      if (currentAcc.role !== Role.Admin && currentAcc.id !== accountToUpdate.id) {\n        return this.unauthorized(\"You are not authorized to update this account.\");\n      }\n      const updateData = Object.assign({}, body);\n      // Prevent role change by non-admin for self\n      if (currentAcc.id === accountToUpdate.id && currentAcc.role !== Role.Admin && updateData.role && updateData.role !== accountToUpdate.role) {\n        return this.error(\"You cannot change your own role.\", 403);\n      }\n      // Only update password if a new one is provided\n      if (updateData.password) {\n        accountToUpdate.password = updateData.password;\n      }\n      // Update other fields\n      ['firstName', 'lastName', 'title', 'email', 'role', 'status', 'employeeId'].forEach(field => {\n        if (updateData[field] !== undefined) {\n          accountToUpdate[field] = updateData[field];\n        }\n      });\n      accountToUpdate.dateUpdated = new Date().toISOString();\n      this.accounts[accountIndex] = accountToUpdate;\n      this.saveAccounts();\n      return this.ok(this.basicDetails(accountToUpdate));\n    }\n    deleteAccount(id, headers) {\n      const currentAcc = this.currentAccount(headers);\n      if (!currentAcc) return this.unauthorized();\n      const accountIndex = this.accounts.findIndex(x => x.id === id);\n      if (accountIndex === -1) return this.error('Account not found', 404);\n      const accountToDelete = this.accounts[accountIndex];\n      if (currentAcc.role !== Role.Admin && currentAcc.id !== accountToDelete.id) {\n        return this.unauthorized(\"You are not authorized to delete this account.\");\n      }\n      // Prevent self-deletion if last admin\n      if (accountToDelete.id === currentAcc.id && accountToDelete.role === Role.Admin && this.accounts.filter(a => a.role === Role.Admin).length <= 1) {\n        return this.error(\"Cannot delete the last admin account.\", 400);\n      }\n      this.accounts.splice(accountIndex, 1);\n      this.saveAccounts();\n      // Also clear cookie if self-deleted\n      if (accountToDelete.id === currentAcc.id) {\n        this.clearRefreshTokenCookie();\n      }\n      return this.ok({\n        message: 'Account deleted successfully.'\n      });\n    }\n    // --- HELPER METHODS ---\n    ok(body, status = 200) {\n      return of(new HttpResponse({\n        status,\n        body\n      }));\n    }\n    error(message, status = 400) {\n      return throwError(() => new HttpErrorResponse({\n        error: {\n          message\n        },\n        status\n      }));\n    }\n    unauthorized(message = 'Unauthorized') {\n      return throwError(() => new HttpErrorResponse({\n        status: 401,\n        error: {\n          message\n        }\n      }));\n    }\n    basicDetails(account) {\n      const {\n        id,\n        title,\n        firstName,\n        lastName,\n        email,\n        role,\n        dateCreated,\n        dateUpdated,\n        isVerified,\n        status,\n        employeeId\n      } = account;\n      return {\n        id,\n        title,\n        firstName,\n        lastName,\n        email,\n        role,\n        dateCreated,\n        dateUpdated,\n        isVerified,\n        status,\n        employeeId\n      };\n    }\n    currentAccount(headers) {\n      const authHeader = headers.get('Authorization');\n      if (!authHeader || !authHeader.startsWith('Bearer ')) return undefined;\n      const token = authHeader.substring(7); // \"Bearer \".length\n      try {\n        // Assuming format: header.payload.signature (we only care about payload)\n        const payloadB64 = token.split('.')[1];\n        if (!payloadB64) return undefined;\n        const tokenPayload = JSON.parse(atob(payloadB64));\n        if (Date.now() >= tokenPayload.exp * 1000) {\n          console.warn(\"Fake backend: JWT token expired\");\n          this.clearRefreshTokenCookie(); // Token expired, clear associated refresh token\n          return undefined;\n        }\n        return this.accounts.find(x => x.id === tokenPayload.id);\n      } catch (e) {\n        console.error(\"Fake backend: Error parsing JWT token\", e);\n        return undefined;\n      }\n    }\n    authorize(headers, requiredRole, successCallback) {\n      const account = this.currentAccount(headers);\n      if (!account) {\n        return this.unauthorized('Missing or invalid authentication token.');\n      }\n      if (requiredRole && account.role !== requiredRole) {\n        return throwError(() => new HttpErrorResponse({\n          status: 403,\n          error: {\n            message: 'Forbidden - Insufficient permissions'\n          }\n        }));\n      }\n      return successCallback();\n    }\n    idFromUrl(url) {\n      const match = url.match(/\\/(\\d+)$/);\n      return match ? parseInt(match[1], 10) : -1;\n    }\n    newAccountId() {\n      return this.accounts.length ? Math.max(0, ...this.accounts.map(x => x.id)) + 1 : 1;\n    }\n    saveAccounts() {\n      localStorage.setItem(accountsKey, JSON.stringify(this.accounts));\n    }\n    generateJwtToken(account) {\n      const payload = {\n        id: account.id,\n        role: account.role,\n        email: account.email,\n        exp: Math.floor(new Date(Date.now() + 15 * 60 * 1000).getTime() / 1000) // 15 minutes\n      };\n\n      const header = btoa(JSON.stringify({\n        alg: 'HS256',\n        typ: 'JWT'\n      }));\n      const encodedPayload = btoa(JSON.stringify(payload));\n      return `${header}.${encodedPayload}.fake-signature-for-demo-only`;\n    }\n    generateRefreshTokenForCookie() {\n      const token = `${Date.now()}-${Math.random().toString(36).substring(2, 12)}`;\n      const expires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toUTCString(); // 7 days\n      if (typeof document !== 'undefined') {\n        // For a fake backend, HttpOnly isn't strictly enforceable by client-side JS,\n        // but SameSite=Lax is good practice.\n        document.cookie = `fakeRefreshToken=${token}; expires=${expires}; path=/; SameSite=Lax`;\n      }\n      return token;\n    }\n    getRefreshTokenFromCookie() {\n      if (typeof document === 'undefined') return undefined;\n      const cookies = document.cookie.split(';');\n      for (let cookie of cookies) {\n        const [name, value] = cookie.trim().split('=');\n        if (name === 'fakeRefreshToken') {\n          return value;\n        }\n      }\n      return undefined;\n    }\n    clearRefreshTokenCookie() {\n      if (typeof document !== 'undefined') {\n        document.cookie = 'fakeRefreshToken=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/; SameSite=Lax';\n      }\n    }\n  }\n  FakeBackendInterceptor.ɵfac = function FakeBackendInterceptor_Factory(t) {\n    return new (t || FakeBackendInterceptor)(i0.ɵɵinject(i1.AlertService));\n  };\n  FakeBackendInterceptor.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: FakeBackendInterceptor,\n    factory: FakeBackendInterceptor.ɵfac\n  });\n  return FakeBackendInterceptor;\n})();\nexport const fakeBackendProvider = {\n  provide: HTTP_INTERCEPTORS,\n  useClass: FakeBackendInterceptor,\n  multi: true\n};","map":{"version":3,"mappings":"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","names":["HttpResponse","HTTP_INTERCEPTORS","HttpErrorResponse","of","throwError","delay","mergeMap","materialize","dematerialize","Role","accountsKey","FakeBackendInterceptor","constructor","alertService","id","employeeId","userId","position","departmentId","hireDate","status","name","description","employeeCount","type","details","task","requestItems","quantity","employees","length","Math","max","map","e","departments","d","workflows","w","appRequests","r","accounts","JSON","parse","localStorage","getItem","push","email","password","role","Admin","isVerified","refreshTokens","dateCreated","Date","toISOString","firstName","lastName","User","saveAccounts","intercept","request","next","url","method","headers","body","pipe","handleRoute","endsWith","authenticate","refreshToken","revokeToken","register","verifyEmail","forgotPassword","validateResetToken","resetPassword","getAccounts","match","getAccountById","idFromUrl","createAccount","updateAccount","deleteAccount","authorize","ok","newEmployee","nextEmployeeId","dept","find","employee","error","employeeIndex","findIndex","oldEmployeeData","updatedEmployee","oldDept","newDept","deletedEmployee","splice","message","idMatch","parseInt","oldDepartmentId","newDepartmentId","nextWorkflowId","newDepartment","nextDepartmentId","deptIndex","filter","newWorkflow","currentAcc","currentAccount","unauthorized","userRequests","emp","newRequest","nextAppRequestId","account","x","setTimeout","verifyUrl","location","origin","verificationToken","info","autoClose","generateRefreshTokenForCookie","accountDetails","basicDetails","jwtToken","generateJwtToken","requestRefreshTokenFromBody","requestRefreshTokenFromCookie","getRefreshTokenFromCookie","requestRefreshToken","includes","tokenToRevoke","token","clearRefreshTokenCookie","newAccountData","newAccount","newAccountId","title","now","random","toString","substring","resetToken","resetTokenExpires","resetUrl","acc","accountIndex","accountToUpdate","updateData","Object","forEach","field","undefined","dateUpdated","accountToDelete","a","authHeader","get","startsWith","payloadB64","split","tokenPayload","atob","exp","console","warn","requiredRole","successCallback","setItem","stringify","payload","floor","getTime","header","btoa","alg","typ","encodedPayload","expires","toUTCString","document","cookie","cookies","value","trim","factory","fakeBackendProvider","provide","useClass","multi"],"sourceRoot":"","sources":["E:\\semifinals\\groupB-fullstack-app\\frontend\\src\\app\\_helpers\\fake-backend.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport {\r\n    HttpRequest,\r\n    HttpResponse,\r\n    HttpHandler,\r\n    HttpEvent,\r\n    HttpInterceptor,\r\n    HTTP_INTERCEPTORS,\r\n    HttpErrorResponse,\r\n    HttpHeaders\r\n} from '@angular/common/http';\r\nimport { Observable, of, throwError } from 'rxjs';\r\nimport { delay, mergeMap, materialize, dematerialize } from 'rxjs/operators';\r\n\r\nimport { AlertService } from '@app/_services'; // Assuming this path is correct\r\nimport { Role } from '@app/_models';        // Assuming this path is correct\r\n\r\n// --- Interfaces - Combining and refining ---\r\ninterface Account {\r\n    id: number;\r\n    title?: string;\r\n    firstName?: string;\r\n    lastName?: string;\r\n    email: string;\r\n    password?: string; // Should be hashed in a real app, stored as-is for fake backend comparison\r\n    role: Role | string;\r\n    employeeId?: number; // Link to an employee\r\n    jwtToken?: string; // For the access token (typically not stored with user, but for response)\r\n    dateCreated?: string;\r\n    dateUpdated?: string;\r\n    isVerified?: boolean;\r\n    verificationToken?: string;\r\n    resetToken?: string;\r\n    resetTokenExpires?: Date | string; // Store as ISO string or Date object\r\n    refreshTokens?: string[]; // Array of active refresh tokens\r\n    status?: 'Active' | 'Inactive' | string;\r\n}\r\n\r\ninterface Employee {\r\n    id: number;\r\n    employeeId: string; // The 'EMP001' style ID\r\n    userId: number; // This should link to Account.id\r\n    position: string;\r\n    departmentId: number;\r\n    hireDate: string;\r\n    status: string;\r\n}\r\n\r\ninterface Department {\r\n    id: number;\r\n    name: string;\r\n    description: string;\r\n    employeeCount: number;\r\n}\r\n\r\ninterface Workflow {\r\n    id: number;\r\n    employeeId: number;\r\n    type: string;\r\n    details: any;\r\n    status: string;\r\n}\r\n\r\ninterface AppRequest { // Renamed from 'RequestItem' to avoid conflict with HttpRequest\r\n    id: number;\r\n    employeeId: number;\r\n    type: string;\r\n    requestItems: { name: string; quantity: number }[];\r\n    status: string;\r\n}\r\n\r\n// Key for localStorage\r\nconst accountsKey = 'app-hr-tool-accounts'; // Made key more specific\r\n\r\n@Injectable()\r\nexport class FakeBackendInterceptor implements HttpInterceptor {\r\n    // --- Data Management ---\r\n    private accounts: Account[];\r\n\r\n    // In-memory for other entities\r\n    private employees: Employee[] = [\r\n        { id: 1, employeeId: 'EMP001', userId: 1, position: 'Developer', departmentId: 1, hireDate: '2025-01-01', status: 'Active' },\r\n        { id: 2, employeeId: 'EMP002', userId: 2, position: 'Designer', departmentId: 2, hireDate: '2025-02-01', status: 'Active' }\r\n    ];\r\n    private departments: Department[] = [\r\n        { id: 1, name: 'Engineering', description: 'Software development team', employeeCount: 1 },\r\n        { id: 2, name: 'Marketing', description: 'Marketing team', employeeCount: 1 }\r\n    ];\r\n    private workflows: Workflow[] = [\r\n        { id: 1, employeeId: 1, type: 'Onboarding', details: { task: 'Setup workstation' }, status: 'Pending' }\r\n    ];\r\n    private appRequests: AppRequest[] = [\r\n        { id: 1, employeeId: 2, type: 'Equipment', requestItems: [{ name: 'Laptop', quantity: 1 }], status: 'Pending' }\r\n    ];\r\n\r\n    // ID Generators for in-memory entities\r\n    private nextEmployeeId = this.employees.length > 0 ? Math.max(0, ...this.employees.map(e => e.id)) + 1 : 1;\r\n    private nextDepartmentId = this.departments.length > 0 ? Math.max(0, ...this.departments.map(d => d.id)) + 1 : 1;\r\n    private nextWorkflowId = this.workflows.length > 0 ? Math.max(0, ...this.workflows.map(w => w.id)) + 1 : 1;\r\n    private nextAppRequestId = this.appRequests.length > 0 ? Math.max(0, ...this.appRequests.map(r => r.id)) + 1 : 1;\r\n\r\n    constructor(private alertService: AlertService) {\r\n        this.accounts = JSON.parse(localStorage.getItem(accountsKey)) || [];\r\n        // Ensure default admin/user if local storage is empty or new\r\n        if (this.accounts.length === 0) {\r\n            this.accounts.push({\r\n                id: 1, email: 'admin@example.com', password: 'admin', role: Role.Admin, employeeId: 1,\r\n                isVerified: true, status: 'Active', refreshTokens: [], dateCreated: new Date().toISOString(),\r\n                firstName: 'Admin', lastName: 'User'\r\n            });\r\n            this.accounts.push({\r\n                id: 2, email: 'user@example.com', password: 'user', role: Role.User, employeeId: 2,\r\n                isVerified: true, status: 'Active', refreshTokens: [], dateCreated: new Date().toISOString(),\r\n                firstName: 'Normal', lastName: 'User'\r\n            });\r\n            this.saveAccounts();\r\n        }\r\n    }\r\n\r\n    intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\r\n        const { url, method, headers, body } = request;\r\n\r\n        return of(null)\r\n            .pipe(mergeMap(() => this.handleRoute(url, method, headers as HttpHeaders, body, next)))\r\n            .pipe(materialize())\r\n            .pipe(delay(500))\r\n            .pipe(dematerialize());\r\n    }\r\n\r\n    private handleRoute(url: string, method: string, headers: HttpHeaders, body: any, next: HttpHandler): Observable<HttpEvent<any>> {\r\n        // --- ACCOUNT MANAGEMENT ROUTES ---\r\n        switch (true) {\r\n            case url.endsWith('/accounts/authenticate') && method === 'POST':\r\n                return this.authenticate(body, headers);\r\n            case url.endsWith('/accounts/refresh-token') && method === 'POST':\r\n                return this.refreshToken(body, headers);\r\n            case url.endsWith('/accounts/revoke-token') && method === 'POST':\r\n                return this.revokeToken(body, headers);\r\n            case url.endsWith('/accounts/register') && method === 'POST':\r\n                return this.register(body);\r\n            case url.endsWith('/accounts/verify-email') && method === 'POST':\r\n                return this.verifyEmail(body);\r\n            case url.endsWith('/accounts/forgot-password') && method === 'POST':\r\n                return this.forgotPassword(body);\r\n            case url.endsWith('/accounts/validate-reset-token') && method === 'POST':\r\n                return this.validateResetToken(body);\r\n            case url.endsWith('/accounts/reset-password') && method === 'POST':\r\n                return this.resetPassword(body);\r\n            case url.endsWith('/accounts') && method === 'GET':\r\n                return this.getAccounts(headers);\r\n            case url.match(/\\/accounts\\/(\\d+)$/) && method === 'GET':\r\n                return this.getAccountById(this.idFromUrl(url), headers);\r\n            case url.endsWith('/accounts') && method === 'POST':\r\n                return this.createAccount(body, headers);\r\n            case url.match(/\\/accounts\\/(\\d+)$/) && method === 'PUT':\r\n                return this.updateAccount(this.idFromUrl(url), body, headers);\r\n            case url.match(/\\/accounts\\/(\\d+)$/) && method === 'DELETE':\r\n                return this.deleteAccount(this.idFromUrl(url), headers);\r\n\r\n            // --- OTHER ENTITY ROUTES ---\r\n            // Employees\r\n            case url.endsWith('/employees') && method === 'GET':\r\n                return this.authorize(headers, null, () => this.ok(this.employees));\r\n            case url.endsWith('/employees') && method === 'POST':\r\n                return this.authorize(headers, Role.Admin, () => {\r\n                    const newEmployee: Employee = { id: this.nextEmployeeId++, ...body };\r\n                    this.employees.push(newEmployee);\r\n                    const dept = this.departments.find(d => d.id === newEmployee.departmentId);\r\n                    if (dept) dept.employeeCount++;\r\n                    return this.ok(newEmployee, 201);\r\n                });\r\n            case url.match(/\\/employees\\/(\\d+)$/) && method === 'GET': {\r\n                const id = this.idFromUrl(url);\r\n                return this.authorize(headers, null, () => {\r\n                    const employee = this.employees.find(e => e.id === id);\r\n                    return employee ? this.ok(employee) : this.error('Employee not found', 404);\r\n                });\r\n            }\r\n            case url.match(/\\/employees\\/(\\d+)$/) && method === 'PUT': {\r\n                const id = this.idFromUrl(url);\r\n                return this.authorize(headers, Role.Admin, () => {\r\n                    const employeeIndex = this.employees.findIndex(e => e.id === id);\r\n                    if (employeeIndex === -1) return this.error('Employee not found', 404);\r\n                    const oldEmployeeData = this.employees[employeeIndex];\r\n                    const updatedEmployee = { ...oldEmployeeData, ...body, id };\r\n                    if (oldEmployeeData.departmentId !== updatedEmployee.departmentId) {\r\n                        const oldDept = this.departments.find(d => d.id === oldEmployeeData.departmentId);\r\n                        if (oldDept) oldDept.employeeCount = Math.max(0, oldDept.employeeCount - 1);\r\n                        const newDept = this.departments.find(d => d.id === updatedEmployee.departmentId);\r\n                        if (newDept) newDept.employeeCount++;\r\n                        else return this.error('Target department not found', 400);\r\n                    }\r\n                    this.employees[employeeIndex] = updatedEmployee;\r\n                    return this.ok(this.employees[employeeIndex]);\r\n                });\r\n            }\r\n            case url.match(/\\/employees\\/(\\d+)$/) && method === 'DELETE': {\r\n                const id = this.idFromUrl(url);\r\n                return this.authorize(headers, Role.Admin, () => {\r\n                    const employeeIndex = this.employees.findIndex(e => e.id === id);\r\n                    if (employeeIndex === -1) return this.error('Employee not found', 404);\r\n                    const deletedEmployee = this.employees.splice(employeeIndex, 1)[0];\r\n                    if (deletedEmployee) {\r\n                        const dept = this.departments.find(d => d.id === deletedEmployee.departmentId);\r\n                        if (dept) dept.employeeCount = Math.max(0, dept.employeeCount - 1);\r\n                    }\r\n                    return this.ok({ message: 'Employee deleted' });\r\n                });\r\n            }\r\n            case url.match(/\\/employees\\/(\\d+)\\/transfer$/) && method === 'POST': {\r\n                const idMatch = url.match(/\\/employees\\/(\\d+)\\/transfer$/);\r\n                if (!idMatch) return this.error('Invalid URL for employee transfer', 400);\r\n                const id = parseInt(idMatch[1]);\r\n                return this.authorize(headers, Role.Admin, () => {\r\n                    const employee = this.employees.find(e => e.id === id);\r\n                    if (!employee) return this.error('Employee not found', 404);\r\n                    const oldDepartmentId = employee.departmentId;\r\n                    const newDepartmentId = body.departmentId;\r\n                    if (oldDepartmentId !== newDepartmentId) {\r\n                        const oldDept = this.departments.find(d => d.id === oldDepartmentId);\r\n                        if (oldDept) oldDept.employeeCount = Math.max(0, oldDept.employeeCount - 1);\r\n                        const newDept = this.departments.find(d => d.id === newDepartmentId);\r\n                        if (newDept) newDept.employeeCount++;\r\n                        else return this.error('Target department not found', 400);\r\n                    }\r\n                    employee.departmentId = newDepartmentId;\r\n                    this.workflows.push({\r\n                        id: this.nextWorkflowId++, employeeId: id, type: 'Transfer',\r\n                        details: body, status: 'Pending'\r\n                    });\r\n                    return this.ok({ message: 'Employee transferred successfully', employee });\r\n                });\r\n            }\r\n\r\n            // Departments\r\n            case url.endsWith('/departments') && method === 'GET':\r\n                return this.authorize(headers, null, () => this.ok(this.departments));\r\n            case url.endsWith('/departments') && method === 'POST':\r\n                return this.authorize(headers, Role.Admin, () => {\r\n                    const newDepartment: Department = { id: this.nextDepartmentId++, ...body, employeeCount: 0 };\r\n                    this.departments.push(newDepartment);\r\n                    return this.ok(newDepartment, 201);\r\n                });\r\n            case url.match(/\\/departments\\/(\\d+)$/) && method === 'PUT': {\r\n                const id = this.idFromUrl(url);\r\n                return this.authorize(headers, Role.Admin, () => {\r\n                    const deptIndex = this.departments.findIndex(d => d.id === id);\r\n                    if (deptIndex === -1) return this.error('Department not found', 404);\r\n                    this.departments[deptIndex] = { ...this.departments[deptIndex], ...body, id };\r\n                    return this.ok(this.departments[deptIndex]);\r\n                });\r\n            }\r\n            case url.match(/\\/departments\\/(\\d+)$/) && method === 'DELETE': {\r\n                const id = this.idFromUrl(url);\r\n                return this.authorize(headers, Role.Admin, () => {\r\n                    const dept = this.departments.find(d => d.id === id);\r\n                    if (!dept) return this.error('Department not found', 404);\r\n                    if (dept.employeeCount > 0) return this.error('Cannot delete department with active employees.', 400);\r\n                    this.departments = this.departments.filter(d => d.id !== id);\r\n                    return this.ok({ message: 'Department deleted' });\r\n                });\r\n            }\r\n\r\n\r\n            // Workflows\r\n            case url.match(/\\/workflows\\/employee\\/(\\d+)$/) && method === 'GET': {\r\n                const idMatch = url.match(/\\/workflows\\/employee\\/(\\d+)$/);\r\n                if (!idMatch) return this.error('Invalid URL for employee workflows', 400);\r\n                const employeeId = parseInt(idMatch[1]);\r\n                return this.authorize(headers, null, () => { // Or specific role if needed\r\n                    const workflows = this.workflows.filter(w => w.employeeId === employeeId);\r\n                    return this.ok(workflows);\r\n                });\r\n            }\r\n            case url.endsWith('/workflows') && method === 'POST':\r\n                return this.authorize(headers, Role.Admin, () => { // Or more specific role\r\n                    const newWorkflow: Workflow = { id: this.nextWorkflowId++, ...body };\r\n                    this.workflows.push(newWorkflow);\r\n                    return this.ok(newWorkflow, 201);\r\n                });\r\n\r\n            // AppRequests\r\n            case url.endsWith('/requests') && method === 'GET':\r\n                return this.authorize(headers, null, () => { // Allow users to see their requests or admin to see all\r\n                    const currentAcc = this.currentAccount(headers);\r\n                    if (!currentAcc) return this.unauthorized();\r\n                    if (currentAcc.role === Role.Admin) return this.ok(this.appRequests);\r\n\r\n                    const userRequests = this.appRequests.filter(r => {\r\n                        const emp = this.employees.find(e => e.id === r.employeeId);\r\n                        return emp && emp.userId === currentAcc.id;\r\n                    });\r\n                    return this.ok(userRequests);\r\n                });\r\n            case url.endsWith('/requests') && method === 'POST':\r\n                return this.authorize(headers, null, () => { // Allow authenticated users to create requests\r\n                    const currentAcc = this.currentAccount(headers);\r\n                    if (!currentAcc || !currentAcc.employeeId) return this.error(\"User not linked to an employee or not authenticated.\", 400);\r\n\r\n                    const newRequest: AppRequest = { id: this.nextAppRequestId++, employeeId: currentAcc.employeeId, ...body, status: 'Pending' };\r\n                    this.appRequests.push(newRequest);\r\n                    return this.ok(newRequest, 201);\r\n                });\r\n\r\n\r\n            default:\r\n                // return next.handle(request); // If you have a real backend\r\n                return throwError(() => new HttpErrorResponse({\r\n                    status: 404, error: { message: `Fake backend: Route not found for ${method} ${url}` }\r\n                }));\r\n        }\r\n    }\r\n\r\n    // --- ACCOUNT MANAGEMENT METHODS ---\r\n    private authenticate(body: any, headers: HttpHeaders): Observable<HttpEvent<any>> {\r\n        const { email, password } = body;\r\n        const account = this.accounts.find(x => x.email === email);\r\n\r\n        if (!account) return this.error('Invalid email or password.', 400); // Generic message\r\n        if (!account.isVerified) {\r\n            setTimeout(() => {\r\n                const verifyUrl = `${location.origin}/account/verify-email?token=${account.verificationToken}`;\r\n                this.alertService.info(`<h4>Verification Email</h4><p>Please click the link to verify: <a href=\"${verifyUrl}\">${verifyUrl}</a></p>`, { autoClose: false });\r\n            }, 1000);\r\n            return this.error('Email is not yet verified. Please check your inbox.', 400);\r\n        }\r\n        if (account.password !== password) return this.error('Invalid email or password.', 400); // Generic message\r\n        if (account.status !== 'Active') return this.error('Account is inactive. Please contact support.', 400);\r\n\r\n        account.refreshTokens = account.refreshTokens || [];\r\n        account.refreshTokens.push(this.generateRefreshTokenForCookie());\r\n        this.saveAccounts();\r\n\r\n        const accountDetails = this.basicDetails(account);\r\n        return this.ok({\r\n            ...accountDetails,\r\n            jwtToken: this.generateJwtToken(account)\r\n        });\r\n    }\r\n\r\n    private refreshToken(body: any, headers: HttpHeaders): Observable<HttpEvent<any>> {\r\n        const requestRefreshTokenFromBody = body.refreshToken;\r\n        const requestRefreshTokenFromCookie = this.getRefreshTokenFromCookie();\r\n        const requestRefreshToken = requestRefreshTokenFromBody || requestRefreshTokenFromCookie;\r\n\r\n\r\n        if (!requestRefreshToken) return this.unauthorized('Refresh token missing.');\r\n\r\n        const account = this.accounts.find(x => x.refreshTokens && x.refreshTokens.includes(requestRefreshToken));\r\n        if (!account) return this.unauthorized('Invalid or expired refresh token.');\r\n\r\n        account.refreshTokens = account.refreshTokens.filter(x => x !== requestRefreshToken); // Remove old\r\n        account.refreshTokens.push(this.generateRefreshTokenForCookie()); // Add new (rotation)\r\n        this.saveAccounts();\r\n\r\n        return this.ok({\r\n            ...this.basicDetails(account),\r\n            jwtToken: this.generateJwtToken(account)\r\n        });\r\n    }\r\n\r\n    private revokeToken(body: any, headers: HttpHeaders): Observable<HttpEvent<any>> {\r\n        const currentAcc = this.currentAccount(headers);\r\n        if (!currentAcc) return this.unauthorized();\r\n\r\n        const tokenToRevoke = body.token || this.getRefreshTokenFromCookie(); // Token from body or current cookie\r\n        const account = this.accounts.find(x => x.id === currentAcc.id);\r\n\r\n        if (account && account.refreshTokens && tokenToRevoke) {\r\n            account.refreshTokens = account.refreshTokens.filter(x => x !== tokenToRevoke);\r\n            this.saveAccounts();\r\n        }\r\n        // Clear cookie if it was the one revoked\r\n        if (tokenToRevoke && tokenToRevoke === this.getRefreshTokenFromCookie()) {\r\n            this.clearRefreshTokenCookie();\r\n        }\r\n        return this.ok({ message: 'Token revoked successfully.' });\r\n    }\r\n\r\n    private register(body: any): Observable<HttpEvent<any>> {\r\n        const newAccountData = body as Partial<Account>; // Use Partial for incoming data\r\n\r\n        if (!newAccountData.email || !newAccountData.password) {\r\n            return this.error('Email and password are required.', 400);\r\n        }\r\n        if (this.accounts.find(x => x.email === newAccountData.email)) {\r\n            setTimeout(() => this.alertService.error(`Email '${newAccountData.email}' is already registered.`), 1000);\r\n            return this.error(`Email '${newAccountData.email}' is already registered.`, 400);\r\n        }\r\n\r\n        const newAccount: Account = {\r\n            id: this.newAccountId(),\r\n            email: newAccountData.email,\r\n            password: newAccountData.password, // Store as is for fake backend\r\n            role: this.accounts.length === 0 ? Role.Admin : Role.User, // First user is Admin\r\n            firstName: newAccountData.firstName || '',\r\n            lastName: newAccountData.lastName || '',\r\n            title: newAccountData.title || '',\r\n            status: this.accounts.length === 0 ? 'Active' : 'Inactive', // First user active, others inactive\r\n            dateCreated: new Date().toISOString(),\r\n            verificationToken: `${Date.now()}-${Math.random().toString(36).substring(2, 10)}`,\r\n            isVerified: this.accounts.length === 0, // First user is auto-verified\r\n            refreshTokens: []\r\n        };\r\n\r\n        this.accounts.push(newAccount);\r\n        this.saveAccounts();\r\n\r\n        if (!newAccount.isVerified) {\r\n            setTimeout(() => {\r\n                const verifyUrl = `${location.origin}/account/verify-email?token=${newAccount.verificationToken}`;\r\n                this.alertService.info(`<h4>Verification Email</h4><p>Thanks for registering! Please click the link to verify your email: <a href=\"${verifyUrl}\">${verifyUrl}</a></p><div><strong>NOTE:</strong> This is a fake email.</div>`, { autoClose: false });\r\n            }, 1000);\r\n        }\r\n        return this.ok({ message: 'Registration successful. Please check your email to verify your account if required.' }, 201);\r\n    }\r\n\r\n    private verifyEmail(body: any): Observable<HttpEvent<any>> {\r\n        const { token } = body;\r\n        if (!token) return this.error('Verification token is required.', 400);\r\n\r\n        const account = this.accounts.find(x => x.verificationToken === token);\r\n        if (!account) return this.error('Verification failed. Invalid or expired token.', 400);\r\n        if (account.isVerified) return this.ok({ message: 'Email already verified.' });\r\n\r\n\r\n        account.isVerified = true;\r\n        account.status = 'Active';\r\n        delete account.verificationToken;\r\n        this.saveAccounts();\r\n        return this.ok({ message: 'Email verified successfully. You can now login.' });\r\n    }\r\n\r\n    private forgotPassword(body: any): Observable<HttpEvent<any>> {\r\n        const { email } = body;\r\n        if (!email) return this.error('Email is required.', 400);\r\n\r\n        const account = this.accounts.find(x => x.email === email);\r\n        if (account) {\r\n            account.resetToken = `${Date.now()}-${Math.random().toString(36).substring(2, 10)}`;\r\n            account.resetTokenExpires = new Date(Date.now() + 24 * 60 * 60 * 1000); // Expires in 24 hours\r\n            this.saveAccounts();\r\n            setTimeout(() => {\r\n                const resetUrl = `${location.origin}/account/reset-password?token=${account.resetToken}`;\r\n                this.alertService.info(`<h4>Reset Password Email</h4><p>Please click the link to reset your password: <a href=\"${resetUrl}\">${resetUrl}</a></p><p>The link will be valid for 24 hours.</p><div><strong>NOTE:</strong> This is a fake email.</div>`, { autoClose: false });\r\n            }, 1000);\r\n        }\r\n        // Always return OK to prevent email enumeration\r\n        return this.ok({ message: 'If your email address is registered, you will receive a password reset link.' });\r\n    }\r\n\r\n    private validateResetToken(body: any): Observable<HttpEvent<any>> {\r\n        const { token } = body;\r\n        if (!token) return this.error('Reset token is required.', 400);\r\n        const account = this.accounts.find(x => x.resetToken === token && x.resetTokenExpires && new Date(x.resetTokenExpires) > new Date());\r\n        return account ? this.ok({ message: 'Token is valid.' }) : this.error('Invalid or expired reset token.', 400);\r\n    }\r\n\r\n    private resetPassword(body: any): Observable<HttpEvent<any>> {\r\n        const { token, password } = body;\r\n        if (!token || !password) return this.error('Token and new password are required.', 400);\r\n\r\n        const account = this.accounts.find(x => x.resetToken === token && x.resetTokenExpires && new Date(x.resetTokenExpires) > new Date());\r\n        if (!account) return this.error('Invalid or expired reset token.', 400);\r\n\r\n        account.password = password; // In a real app, hash this\r\n        account.isVerified = true; // Good to ensure\r\n        account.status = 'Active';\r\n        delete account.resetToken;\r\n        delete account.resetTokenExpires;\r\n        this.saveAccounts();\r\n        return this.ok({ message: 'Password has been reset successfully. You can now login.' });\r\n    }\r\n\r\n    private getAccounts(headers: HttpHeaders): Observable<HttpEvent<any>> {\r\n        return this.authorize(headers, Role.Admin, () => {\r\n            return this.ok(this.accounts.map(acc => this.basicDetails(acc)));\r\n        });\r\n    }\r\n\r\n    private getAccountById(id: number, headers: HttpHeaders): Observable<HttpEvent<any>> {\r\n        const currentAcc = this.currentAccount(headers);\r\n        if (!currentAcc) return this.unauthorized();\r\n\r\n        const account = this.accounts.find(x => x.id === id);\r\n        if (!account) return this.error('Account not found', 404);\r\n\r\n        if (currentAcc.role !== Role.Admin && currentAcc.id !== account.id) {\r\n            return this.unauthorized(\"You are not authorized to view this account.\");\r\n        }\r\n        return this.ok(this.basicDetails(account));\r\n    }\r\n\r\n    private createAccount(body: any, headers: HttpHeaders): Observable<HttpEvent<any>> {\r\n        return this.authorize(headers, Role.Admin, () => {\r\n            const newAccountData = body as Partial<Account>;\r\n            if (!newAccountData.email || !newAccountData.password || !newAccountData.role) {\r\n                return this.error('Email, password, and role are required for new account creation.', 400);\r\n            }\r\n            if (this.accounts.find(x => x.email === newAccountData.email)) {\r\n                return this.error(`Email '${newAccountData.email}' is already registered`, 400);\r\n            }\r\n            const newAccount: Account = {\r\n                id: this.newAccountId(),\r\n                email: newAccountData.email,\r\n                password: newAccountData.password,\r\n                role: newAccountData.role,\r\n                firstName: newAccountData.firstName || '',\r\n                lastName: newAccountData.lastName || '',\r\n                title: newAccountData.title || '',\r\n                dateCreated: new Date().toISOString(),\r\n                isVerified: true, // Admin created accounts are auto-verified\r\n                status: 'Active', // Admin created accounts are auto-active\r\n                refreshTokens: [],\r\n                employeeId: newAccountData.employeeId // Optional\r\n            };\r\n            this.accounts.push(newAccount);\r\n            this.saveAccounts();\r\n            return this.ok(this.basicDetails(newAccount), 201);\r\n        });\r\n    }\r\n\r\n    private updateAccount(id: number, body: any, headers: HttpHeaders): Observable<HttpEvent<any>> {\r\n        const currentAcc = this.currentAccount(headers);\r\n        if (!currentAcc) return this.unauthorized();\r\n\r\n        const accountIndex = this.accounts.findIndex(x => x.id === id);\r\n        if (accountIndex === -1) return this.error('Account not found', 404);\r\n        const accountToUpdate = this.accounts[accountIndex];\r\n\r\n        if (currentAcc.role !== Role.Admin && currentAcc.id !== accountToUpdate.id) {\r\n            return this.unauthorized(\"You are not authorized to update this account.\");\r\n        }\r\n\r\n        const updateData = { ...body } as Partial<Account>;\r\n        // Prevent role change by non-admin for self\r\n        if (currentAcc.id === accountToUpdate.id && currentAcc.role !== Role.Admin && updateData.role && updateData.role !== accountToUpdate.role) {\r\n            return this.error(\"You cannot change your own role.\", 403);\r\n        }\r\n\r\n        // Only update password if a new one is provided\r\n        if (updateData.password) {\r\n            accountToUpdate.password = updateData.password;\r\n        }\r\n        // Update other fields\r\n        ['firstName', 'lastName', 'title', 'email', 'role', 'status', 'employeeId'].forEach(field => {\r\n            if (updateData[field] !== undefined) {\r\n                accountToUpdate[field] = updateData[field];\r\n            }\r\n        });\r\n\r\n        accountToUpdate.dateUpdated = new Date().toISOString();\r\n        this.accounts[accountIndex] = accountToUpdate;\r\n        this.saveAccounts();\r\n        return this.ok(this.basicDetails(accountToUpdate));\r\n    }\r\n\r\n    private deleteAccount(id: number, headers: HttpHeaders): Observable<HttpEvent<any>> {\r\n        const currentAcc = this.currentAccount(headers);\r\n        if (!currentAcc) return this.unauthorized();\r\n\r\n        const accountIndex = this.accounts.findIndex(x => x.id === id);\r\n        if (accountIndex === -1) return this.error('Account not found', 404);\r\n\r\n        const accountToDelete = this.accounts[accountIndex];\r\n        if (currentAcc.role !== Role.Admin && currentAcc.id !== accountToDelete.id) {\r\n            return this.unauthorized(\"You are not authorized to delete this account.\");\r\n        }\r\n        // Prevent self-deletion if last admin\r\n        if (accountToDelete.id === currentAcc.id && accountToDelete.role === Role.Admin && this.accounts.filter(a => a.role === Role.Admin).length <= 1) {\r\n            return this.error(\"Cannot delete the last admin account.\", 400);\r\n        }\r\n\r\n        this.accounts.splice(accountIndex, 1);\r\n        this.saveAccounts();\r\n        // Also clear cookie if self-deleted\r\n        if (accountToDelete.id === currentAcc.id) {\r\n            this.clearRefreshTokenCookie();\r\n        }\r\n        return this.ok({ message: 'Account deleted successfully.' });\r\n    }\r\n\r\n    // --- HELPER METHODS ---\r\n    private ok(body?: any, status = 200): Observable<HttpResponse<any>> {\r\n        return of(new HttpResponse({ status, body }));\r\n    }\r\n\r\n    private error(message: string, status = 400): Observable<HttpEvent<never>> {\r\n        return throwError(() => new HttpErrorResponse({ error: { message }, status }));\r\n    }\r\n\r\n    private unauthorized(message = 'Unauthorized'): Observable<HttpEvent<never>> {\r\n        return throwError(() => new HttpErrorResponse({ status: 401, error: { message } }));\r\n    }\r\n\r\n    private basicDetails(account: Account): Partial<Account> {\r\n        const { id, title, firstName, lastName, email, role, dateCreated, dateUpdated, isVerified, status, employeeId } = account;\r\n        return { id, title, firstName, lastName, email, role, dateCreated, dateUpdated, isVerified, status, employeeId };\r\n    }\r\n\r\n    private currentAccount(headers: HttpHeaders): Account | undefined {\r\n        const authHeader = headers.get('Authorization');\r\n        if (!authHeader || !authHeader.startsWith('Bearer ')) return undefined;\r\n\r\n        const token = authHeader.substring(7); // \"Bearer \".length\r\n        try {\r\n            // Assuming format: header.payload.signature (we only care about payload)\r\n            const payloadB64 = token.split('.')[1];\r\n            if (!payloadB64) return undefined;\r\n\r\n            const tokenPayload = JSON.parse(atob(payloadB64));\r\n            if (Date.now() >= tokenPayload.exp * 1000) {\r\n                console.warn(\"Fake backend: JWT token expired\");\r\n                this.clearRefreshTokenCookie(); // Token expired, clear associated refresh token\r\n                return undefined;\r\n            }\r\n            return this.accounts.find(x => x.id === tokenPayload.id);\r\n        } catch (e) {\r\n            console.error(\"Fake backend: Error parsing JWT token\", e);\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    private authorize(headers: HttpHeaders, requiredRole: Role | string | null, successCallback: () => Observable<HttpEvent<any>>): Observable<HttpEvent<any>> {\r\n        const account = this.currentAccount(headers);\r\n        if (!account) {\r\n            return this.unauthorized('Missing or invalid authentication token.');\r\n        }\r\n        if (requiredRole && account.role !== requiredRole) {\r\n            return throwError(() => new HttpErrorResponse({ status: 403, error: { message: 'Forbidden - Insufficient permissions' } }));\r\n        }\r\n        return successCallback();\r\n    }\r\n\r\n    private idFromUrl(url: string): number {\r\n        const match = url.match(/\\/(\\d+)$/);\r\n        return match ? parseInt(match[1], 10) : -1;\r\n    }\r\n\r\n    private newAccountId(): number {\r\n        return this.accounts.length ? Math.max(0, ...this.accounts.map(x => x.id)) + 1 : 1;\r\n    }\r\n\r\n    private saveAccounts(): void {\r\n        localStorage.setItem(accountsKey, JSON.stringify(this.accounts));\r\n    }\r\n\r\n    private generateJwtToken(account: Account): string {\r\n        const payload = {\r\n            id: account.id,\r\n            role: account.role,\r\n            email: account.email, // Good to include for display/reference\r\n            exp: Math.floor(new Date(Date.now() + 15 * 60 * 1000).getTime() / 1000), // 15 minutes\r\n        };\r\n        const header = btoa(JSON.stringify({ alg: 'HS256', typ: 'JWT' }));\r\n        const encodedPayload = btoa(JSON.stringify(payload));\r\n        return `${header}.${encodedPayload}.fake-signature-for-demo-only`;\r\n    }\r\n\r\n    private generateRefreshTokenForCookie(): string {\r\n        const token = `${Date.now()}-${Math.random().toString(36).substring(2, 12)}`;\r\n        const expires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toUTCString(); // 7 days\r\n        if (typeof document !== 'undefined') {\r\n            // For a fake backend, HttpOnly isn't strictly enforceable by client-side JS,\r\n            // but SameSite=Lax is good practice.\r\n            document.cookie = `fakeRefreshToken=${token}; expires=${expires}; path=/; SameSite=Lax`;\r\n        }\r\n        return token;\r\n    }\r\n\r\n    private getRefreshTokenFromCookie(): string | undefined {\r\n        if (typeof document === 'undefined') return undefined;\r\n        const cookies = document.cookie.split(';');\r\n        for (let cookie of cookies) {\r\n            const [name, value] = cookie.trim().split('=');\r\n            if (name === 'fakeRefreshToken') {\r\n                return value;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    private clearRefreshTokenCookie(): void {\r\n        if (typeof document !== 'undefined') {\r\n            document.cookie = 'fakeRefreshToken=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/; SameSite=Lax';\r\n        }\r\n    }\r\n}\r\n\r\nexport const fakeBackendProvider = {\r\n    provide: HTTP_INTERCEPTORS,\r\n    useClass: FakeBackendInterceptor,\r\n    multi: true\r\n};"]},"metadata":{},"sourceType":"module","externalDependencies":[]}