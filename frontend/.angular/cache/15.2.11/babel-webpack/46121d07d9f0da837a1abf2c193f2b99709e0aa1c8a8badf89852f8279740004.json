{"ast":null,"code":"import { HttpResponse, HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { of, throwError } from 'rxjs';\nimport { delay, mergeMap, materialize, dematerialize } from 'rxjs/operators';\nimport { Role } from '@app/_models';\nimport { environment } from '@environments/environment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@app/_services\";\n// array in local storage for accounts\nconst accountsKey = 'angular-10-registration-login-example-accounts';\nlet accounts = JSON.parse(localStorage.getItem(accountsKey)) || [];\n// in-memory data\nlet employees = [{\n  id: 1,\n  employeeId: 'EMP001',\n  userId: 1,\n  position: 'Developer',\n  departmentId: 1,\n  hireDate: '2025-01-01',\n  status: 'Active'\n}, {\n  id: 2,\n  employeeId: 'EMP002',\n  userId: 2,\n  position: 'Designer',\n  departmentId: 2,\n  hireDate: '2025-02-01',\n  status: 'Active'\n}];\nlet departments = [{\n  id: 1,\n  name: 'Engineering',\n  description: 'Software development team',\n  employeeCount: 1\n}, {\n  id: 2,\n  name: 'Marketing',\n  description: 'Marketing team',\n  employeeCount: 1\n}];\nlet workflows = [{\n  id: 1,\n  employeeId: 1,\n  type: 'Onboarding',\n  details: 'Task: Setup workstation',\n  status: 'Pending'\n}];\nlet requests = [{\n  id: 1,\n  employeeId: 1,\n  type: 'Equipment',\n  requestItems: [{\n    name: 'Laptop',\n    quantity: 1\n  }, {\n    name: 'Monitor',\n    quantity: 2\n  }],\n  status: 'Pending'\n}, {\n  id: 2,\n  employeeId: 1,\n  type: 'Software',\n  requestItems: [{\n    name: 'Visual Studio',\n    quantity: 1\n  }, {\n    name: 'Office 365',\n    quantity: 1\n  }],\n  status: 'Approved'\n}, {\n  id: 3,\n  employeeId: 2,\n  type: 'Training',\n  requestItems: [{\n    name: 'Adobe Illustrator Course',\n    quantity: 1\n  }],\n  status: 'Rejected'\n}, {\n  id: 4,\n  employeeId: 2,\n  type: 'Equipment',\n  requestItems: [{\n    name: 'Drawing Tablet',\n    quantity: 1\n  }],\n  status: 'Pending'\n}];\nexport let FakeBackendInterceptor = /*#__PURE__*/(() => {\n  class FakeBackendInterceptor {\n    constructor(alertService) {\n      this.alertService = alertService;\n    }\n    intercept(request, next) {\n      const {\n        url,\n        method,\n        headers,\n        body\n      } = request;\n      const alertService = this.alertService;\n      // Extract the path from the URL (remove the API prefix if present)\n      const apiUrl = environment.apiUrl;\n      const path = url.startsWith(apiUrl) ? url.substring(apiUrl.length) : url;\n      return of(null).pipe(mergeMap(() => handleRoute())).pipe(materialize()).pipe(delay(500)).pipe(dematerialize());\n      function handleRoute() {\n        switch (true) {\n          // Account endpoints\n          case path.endsWith('/accounts/authenticate') && method === 'POST':\n            return authenticate();\n          case path.endsWith('/accounts/refresh-token') && method === 'POST':\n            return refreshToken();\n          case path.endsWith('/accounts/revoke-token') && method === 'POST':\n            return revokeToken();\n          case path.endsWith('/accounts/register') && method === 'POST':\n            return register();\n          case path.endsWith('/accounts/verify-email') && method === 'POST':\n            return verifyEmail();\n          case path.endsWith('/accounts/forgot-password') && method === 'POST':\n            return forgotPassword();\n          case path.endsWith('/accounts/validate-reset-token') && method === 'POST':\n            return validateResetToken();\n          case path.endsWith('/accounts/reset-password') && method === 'POST':\n            return resetPassword();\n          case path.endsWith('/accounts') && method === 'GET':\n            return getAccounts();\n          case path.match(/\\/accounts\\/\\d+$/) && method === 'GET':\n            return getAccountById();\n          case path.endsWith('/accounts') && method === 'POST':\n            return createAccount();\n          case path.match(/\\/accounts\\/\\d+$/) && method === 'PUT':\n            return updateAccount();\n          // Employee endpoints\n          case path.endsWith('/employees') && method === 'GET':\n            return authorize(null, () => getEmployees());\n          case path.endsWith('/employees/nextId') && method === 'GET':\n            return authorize(null, () => getNextEmployeeId());\n          case path.endsWith('/employees') && method === 'POST':\n            return authorize(Role.Admin, () => createEmployee());\n          case path.match(/\\/employees\\/\\d+$/) && method === 'GET':\n            return authorize(null, () => getEmployeeById());\n          case path.match(/\\/employees\\/\\d+\\/with-details$/) && method === 'GET':\n            return authorize(null, () => getEmployeeWithDetails());\n          case path.match(/\\/employees\\/\\d+$/) && method === 'PUT':\n            return authorize(Role.Admin, () => updateEmployee());\n          case path.match(/\\/employees\\/\\d+\\/transfer$/) && method === 'POST':\n            return authorize(Role.Admin, () => transferEmployee());\n          // Department endpoints\n          case path.endsWith('/departments') && method === 'GET':\n            return authorize(null, () => getDepartments());\n          case path.endsWith('/departments') && method === 'POST':\n            return authorize(Role.Admin, () => createDepartment());\n          case path.match(/\\/departments\\/\\d+$/) && method === 'GET':\n            return authorize(null, () => getDepartmentById());\n          case path.match(/\\/departments\\/\\d+$/) && method === 'PUT':\n            return authorize(Role.Admin, () => updateDepartment());\n          // Workflow endpoints\n          case path.match(/\\/workflows\\/employee\\/\\d+$/) && method === 'GET':\n            return authorize(null, () => getEmployeeWorkflows());\n          case path.endsWith('/workflows') && method === 'GET':\n            return authorize(null, () => getAllWorkflows());\n          case path.endsWith('/workflows') && method === 'POST':\n            return authorize(Role.Admin, () => createWorkflow());\n          case path.match(/\\/workflows\\/\\d+\\/status$/) && method === 'PUT':\n            return authorize(Role.Admin, () => updateWorkflow());\n          case path.match(/\\/workflows\\/\\d+$/) && method === 'PUT':\n            return authorize(Role.Admin, () => updateWorkflow());\n          // Request endpoints\n          case path.endsWith('/requests') && method === 'GET':\n            return authorize(null, () => getRequests());\n          case path.match(/\\/requests\\?employeeId=\\d+$/) && method === 'GET':\n            return authorize(null, () => getRequestsByEmployeeId());\n          case path.match(/\\/requests\\/\\d+$/) && method === 'GET':\n            return authorize(null, () => getRequestById());\n          case path.endsWith('/requests') && method === 'POST':\n            return authorize(null, () => createRequest());\n          case path.match(/\\/requests\\/\\d+$/) && method === 'PUT':\n            return authorize(Role.Admin, () => updateRequest());\n          default:\n            // pass through any requests not handled above\n            return next.handle(request);\n        }\n      }\n      // Account route functions\n      function authenticate() {\n        const {\n          email,\n          password\n        } = body;\n        const account = accounts.find(x => x.email === email);\n        if (!account) {\n          return error('Email does not exist');\n        }\n        if (!account.isVerified) {\n          // Display verification email alert\n          setTimeout(() => {\n            const verifyUrl = `${location.origin}/account/verify-email?token=${account.verificationToken}`;\n            alertService.info(`\n                        <h4>Verification Email</h4>\n                        <p>Please click the below link to verify your email address:</p>\n                        <p><a href=\"${verifyUrl}\">${verifyUrl}</a></p>\n                    `, {\n              autoClose: false\n            });\n          }, 1000);\n          return error('Email is not yet verified');\n        }\n        if (account.password !== password) {\n          return error('Incorrect password');\n        }\n        if (account.status !== 'Active') {\n          return error('Account is inactive. Please contact support.');\n        }\n        account.refreshTokens.push(generateRefreshToken());\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok(Object.assign(Object.assign({}, basicDetails(account)), {\n          jwtToken: generateJwtToken(account)\n        }));\n      }\n      function refreshToken() {\n        const refreshToken = getRefreshToken();\n        if (!refreshToken) return unauthorized();\n        const account = accounts.find(x => x.refreshTokens.includes(refreshToken));\n        if (!account) return unauthorized();\n        // replace old refresh token with a new one and save\n        account.refreshTokens = account.refreshTokens.filter(x => x !== refreshToken);\n        account.refreshTokens.push(generateRefreshToken());\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok(Object.assign(Object.assign({}, basicDetails(account)), {\n          jwtToken: generateJwtToken(account)\n        }));\n      }\n      function revokeToken() {\n        if (!isAuthenticated()) return unauthorized();\n        const refreshToken = getRefreshToken();\n        const account = accounts.find(x => x.refreshTokens.includes(refreshToken));\n        // revoke token and save\n        account.refreshTokens = account.refreshTokens.filter(x => x !== refreshToken);\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok();\n      }\n      function register() {\n        const account = body;\n        if (accounts.find(x => x.email === account.email)) {\n          // display email already registered message in alert\n          setTimeout(() => {\n            alertService.info(`\n                        <h4>Email Already Registered</h4>\n                        <p>Your email ${account.email} is already registered.</p>\n                        <p>If you don't know your password please visit the <a href=\"${location.origin}/account/forgot-password\">forgot password</a> page.</p>\n                        <div>\n                        <strong>NOTE:</strong> The fake backend displayed this \"email\" so you can test without an API. A real backend would send a real email.\n                        </div>\n                    `, {\n              autoclose: false\n            });\n          }, 1000);\n          // always return ok() response to prevent email enumeration\n          return ok();\n        }\n        // assign account id and a few other properties then save\n        account.id = newAccountId();\n        if (account.id === 1) {\n          // first registered account is an admin\n          account.role = Role.Admin;\n          account.status = 'Active'; // Admin accounts get active status\n        } else {\n          account.role = Role.User;\n          account.status = 'Inactive'; // User accounts get inacitve status upon creation\n        }\n\n        account.dateCreated = new Date().toISOString();\n        account.verificationToken = new Date().getTime().toString();\n        account.isVerified = false;\n        account.refreshTokens = [];\n        delete account.confirmPassword;\n        accounts.push(account);\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        // display verification email in alert\n        setTimeout(() => {\n          const verifyUrl = `${location.origin}/account/verify-email?token=${account.verificationToken}`;\n          alertService.info(`\n                    <h4>Verification Email</h4>\n                    <p>Thanks for registering!</p>\n                    <p>Please click the below link to verify your email address:</p>\n                    <p><a href=\"${verifyUrl}\">${verifyUrl}</a></p>\n                    <div><strong>NOTE:</strong> The fake backend displayed this \"email\" so you can test without an API. A real backend would send a real email.</div>\n                `, {\n            autoclose: false\n          });\n        }, 1000);\n        return ok();\n      }\n      function verifyEmail() {\n        const {\n          token\n        } = body;\n        const account = accounts.find(x => !!x.verificationToken && x.verificationToken === token);\n        if (!account) return error('Verification failed');\n        // set is verified flag to true if token is valid\n        account.isVerified = true;\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok();\n      }\n      function forgotPassword() {\n        const {\n          email\n        } = body;\n        const account = accounts.find(x => x.email === email);\n        // always return ok() response to prevent email enumeration\n        if (!account) return ok();\n        // create reset token that expires after 24 hours\n        account.resetToken = new Date().getTime().toString();\n        account.resetTokenExpires = new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString();\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        // display password reset email in alert\n        setTimeout(() => {\n          const resetUrl = `${location.origin}/account/reset-password?token=${account.resetToken}`;\n          alertService.info(`\n                    <h4>Reset Password Email</h4>\n                    <p>Please click the below link to reset your password, the link will be valid for 1 day:</p>\n                    <p><a href=\"${resetUrl}\">${resetUrl}</a></p>\n                    <div><strong>NOTE:</strong> The fake backend displayed this \"email\" so you can test without an API. A real backend would send a real email.</div>\n                `, {\n            autoClose: false\n          });\n        }, 1000);\n        return ok();\n      }\n      function validateResetToken() {\n        const {\n          token\n        } = body;\n        const account = accounts.find(x => !!x.resetToken && x.resetToken === token && new Date() < new Date(x.resetTokenExpires));\n        if (!account) return error(\"Invalid token\");\n        return ok();\n      }\n      function resetPassword() {\n        const {\n          token,\n          password\n        } = body;\n        const account = accounts.find(x => !!x.resetToken && x.resetToken === token && new Date() < new Date(x.resetTokenExpires));\n        if (!account) return error('Invalid token');\n        // update password and remove reset token\n        account.password = password;\n        account.isVerified = true;\n        delete account.resetToken;\n        delete account.resetTokenExpires;\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok();\n      }\n      function getAccounts() {\n        if (!isAuthenticated()) return unauthorized();\n        return ok(accounts.map(x => basicDetails(x)));\n      }\n      function getAccountById() {\n        if (!isAuthenticated()) return unauthorized();\n        let account = accounts.find(x => x.id === idFromUrl());\n        // user accounts can get own profile and admin accounts can get all profiles\n        if (account.id !== currentAccount().id && !isAuthorized(Role.Admin)) {\n          return unauthorized();\n        }\n        return ok(basicDetails(account));\n      }\n      function createAccount() {\n        if (!isAuthorized(Role.Admin)) return unauthorized();\n        const account = body;\n        if (accounts.find(x => x.email === account.email)) {\n          return error(`Email ${account.email} is already registered`);\n        }\n        // assign account id and a few other properties then save\n        account.id = newAccountId();\n        account.status = 'Inactive';\n        account.dateCreated = new Date().toISOString();\n        account.isVerified = true;\n        account.refreshTokens = [];\n        delete account.confirmPassword;\n        accounts.push(account);\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok();\n      }\n      function updateAccount() {\n        if (!isAuthenticated()) return unauthorized();\n        let params = body;\n        let account = accounts.find(x => x.id == idFromUrl());\n        // user accounts can update own profile and admin accounts can update all profiles\n        if (account.id != currentAccount().id && !isAuthorized(Role.Admin)) {\n          return unauthorized();\n        }\n        // only update password if included\n        if (!params.password) {\n          delete params.password;\n        }\n        // update and save account\n        Object.assign(account, params);\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok();\n      }\n      // Employee route functions\n      function getEmployees() {\n        // Map employees with account and department information\n        const enrichedEmployees = employees.map(employee => {\n          // Get user account details\n          const user = accounts.find(a => a.id === employee.userId);\n          // Get department details\n          const department = departments.find(d => d.id === employee.departmentId);\n          // Create a response with the related details\n          return Object.assign(Object.assign({}, employee), {\n            User: user ? {\n              id: user.id,\n              email: user.email,\n              role: user.role,\n              firstName: user.firstName,\n              lastName: user.lastName\n            } : null,\n            Department: department ? {\n              id: department.id,\n              name: department.name\n            } : null\n          });\n        });\n        return ok(enrichedEmployees);\n      }\n      function createEmployee() {\n        // Generate employee ID in format 'EMP' + padded number if not provided\n        let employeeId = body.employeeId;\n        if (!employeeId || !employeeId.trim()) {\n          const nextId = employees.length + 1;\n          employeeId = 'EMP' + nextId.toString().padStart(3, '0');\n        }\n        // Verify the userId exists in accounts\n        const userId = parseInt(body.userId);\n        if (isNaN(userId)) {\n          return error('Please select a valid user');\n        }\n        const userExists = accounts.some(a => a.id === userId);\n        if (!userExists) {\n          return error('User not found');\n        }\n        // Verify the departmentId exists\n        const departmentId = parseInt(body.departmentId);\n        if (isNaN(departmentId)) {\n          return error('Please select a valid department');\n        }\n        const department = departments.find(d => d.id === departmentId);\n        if (!department) {\n          return error('Department not found');\n        }\n        // Create the employee with auto-generated ID\n        const nextId = employees.length + 1;\n        const employee = {\n          id: nextId,\n          employeeId: employeeId,\n          userId: userId,\n          departmentId: departmentId,\n          position: body.position || '',\n          hireDate: body.hireDate || new Date().toISOString().split('T')[0],\n          status: body.status || 'Active'\n        };\n        // Add to employees array\n        employees.push(employee);\n        // Update department employee count\n        department.employeeCount++;\n        // Create onboarding workflow\n        workflows.push({\n          id: workflows.length + 1,\n          employeeId: nextId,\n          type: 'Onboarding',\n          details: 'Task: Setup workstation',\n          status: 'Pending'\n        });\n        return ok(employee);\n      }\n      function getEmployeeById() {\n        const id = parseInt(path.split('/').pop());\n        const employee = employees.find(e => e.id === id);\n        if (!employee) return error('Employee not found');\n        return ok(employee);\n      }\n      function getEmployeeWithDetails() {\n        const id = parseInt(path.split('/').pop().split('/')[0]);\n        const employee = employees.find(e => e.id === id);\n        if (!employee) return error('Employee not found');\n        // Get user account details\n        const user = accounts.find(a => a.id === employee.userId);\n        // Get department details\n        const department = departments.find(d => d.id === employee.departmentId);\n        // Create a response with the related details\n        const response = Object.assign(Object.assign({}, employee), {\n          User: user ? {\n            id: user.id,\n            email: user.email,\n            role: user.role\n          } : null,\n          Department: department ? {\n            id: department.id,\n            name: department.name\n          } : null\n        });\n        return ok(response);\n      }\n      function updateEmployee() {\n        const id = parseInt(path.split('/').pop());\n        const employeeIndex = employees.findIndex(e => e.id === id);\n        if (employeeIndex === -1) return error('Employee not found');\n        // Parse values to ensure they're numbers\n        let userId = body.userId;\n        if (userId && typeof userId === 'string') {\n          userId = parseInt(userId);\n        }\n        let departmentId = body.departmentId;\n        if (departmentId && typeof departmentId === 'string') {\n          departmentId = parseInt(departmentId);\n        }\n        // Check if user exists if userId is being updated\n        if (userId) {\n          const userExists = accounts.some(a => a.id === userId);\n          if (!userExists) {\n            return error('User not found');\n          }\n        }\n        // Check if department exists if departmentId is being updated\n        if (departmentId && departmentId !== employees[employeeIndex].departmentId) {\n          const oldDepartmentId = employees[employeeIndex].departmentId;\n          const oldDepartment = departments.find(d => d.id === oldDepartmentId);\n          const newDepartment = departments.find(d => d.id === departmentId);\n          if (!newDepartment) {\n            return error('Department not found');\n          }\n          // Update department employee counts\n          if (oldDepartment) oldDepartment.employeeCount--;\n          newDepartment.employeeCount++;\n        }\n        // Keep the employeeId unchanged\n        const employeeId = employees[employeeIndex].employeeId;\n        // Create updated employee object with parsed values\n        const updatedEmployee = {\n          id,\n          employeeId,\n          userId: userId || employees[employeeIndex].userId,\n          departmentId: departmentId || employees[employeeIndex].departmentId,\n          position: body.position || employees[employeeIndex].position,\n          hireDate: body.hireDate || employees[employeeIndex].hireDate,\n          status: body.status || employees[employeeIndex].status\n        };\n        // Update the employee\n        employees[employeeIndex] = updatedEmployee;\n        return ok(updatedEmployee);\n      }\n      function transferEmployee() {\n        const id = parseInt(path.split('/')[2]);\n        const employee = employees.find(e => e.id === id);\n        if (!employee) return error('Employee not found');\n        // Get department information\n        const oldDepartmentId = employee.departmentId;\n        const newDepartmentId = body.departmentId;\n        const oldDepartment = departments.find(d => d.id === oldDepartmentId);\n        const newDepartment = departments.find(d => d.id === newDepartmentId);\n        // Update employee's department\n        employee.departmentId = newDepartmentId;\n        // Update department counts\n        if (oldDepartment) oldDepartment.employeeCount--;\n        if (newDepartment) newDepartment.employeeCount++;\n        // Create transfer workflow\n        workflows.push({\n          id: workflows.length + 1,\n          employeeId: id,\n          type: 'Department Transfer',\n          details: `Employee transferred from ${(oldDepartment === null || oldDepartment === void 0 ? void 0 : oldDepartment.name) || 'Unknown'} to ${(newDepartment === null || newDepartment === void 0 ? void 0 : newDepartment.name) || 'Unknown'}.`,\n          status: 'Pending'\n        });\n        return ok({\n          message: `Department transfer workflow created for employee ${employee.employeeId}.`\n        });\n      }\n      // Department route functions\n      function getDepartments() {\n        return ok(departments);\n      }\n      function getDepartmentById() {\n        const id = parseInt(path.split('/').pop());\n        const department = departments.find(d => d.id === id);\n        if (!department) return error('Department not found');\n        return ok(department);\n      }\n      function createDepartment() {\n        // Check if department with same name already exists\n        if (departments.some(d => d.name.toLowerCase() === body.name.toLowerCase())) {\n          return error('Department with this name already exists');\n        }\n        // Create department with initial employee count of 0\n        const department = {\n          id: departments.length + 1,\n          name: body.name,\n          description: body.description,\n          employeeCount: 0\n        };\n        departments.push(department);\n        return ok(department);\n      }\n      function updateDepartment() {\n        const id = parseInt(path.split('/').pop());\n        const deptIndex = departments.findIndex(d => d.id === id);\n        if (deptIndex === -1) return error('Department not found');\n        // Check if name is being changed and if it already exists\n        if (body.name && body.name !== departments[deptIndex].name) {\n          if (departments.some(d => d.id !== id && d.name.toLowerCase() === body.name.toLowerCase())) {\n            return error('Department with this name already exists');\n          }\n        }\n        // Update department\n        departments[deptIndex] = Object.assign(Object.assign({}, departments[deptIndex]), {\n          name: body.name || departments[deptIndex].name,\n          description: body.description || departments[deptIndex].description\n        });\n        return ok(departments[deptIndex]);\n      }\n      // Workflow route functions\n      function getEmployeeWorkflows() {\n        const employeeId = parseInt(path.split('/').pop());\n        return ok(workflows.filter(w => w.employeeId === employeeId));\n      }\n      function getAllWorkflows() {\n        return ok(workflows);\n      }\n      function createWorkflow() {\n        const workflow = Object.assign({\n          id: workflows.length + 1\n        }, body);\n        workflows.push(workflow);\n        return ok(workflow);\n      }\n      function updateWorkflow() {\n        // Handle both direct update and status update endpoints\n        let id;\n        if (path.includes('/workflows/') && path.includes('/status')) {\n          // Extract ID from paths like /workflows/123/status\n          id = parseInt(path.split('/')[2]);\n        } else {\n          // Standard path like /workflows/123\n          id = parseInt(path.split('/').pop());\n        }\n        const workflowIndex = workflows.findIndex(w => w.id === id);\n        if (workflowIndex === -1) return error('Workflow not found');\n        // Store previous status\n        const oldStatus = workflows[workflowIndex].status;\n        const oldWorkflow = Object.assign({}, workflows[workflowIndex]);\n        // Check if this is an update that includes a direct request for updating request status too\n        const updateRequestFlag = body.updateRequest === true;\n        let providedRequestId = body.requestId ? parseInt(body.requestId) : null;\n        // Create a new version of the body without the special properties\n        const workflowUpdateBody = Object.assign({}, body);\n        delete workflowUpdateBody.updateRequest;\n        delete workflowUpdateBody.requestId;\n        // Update workflow with clean data\n        workflows[workflowIndex] = Object.assign(Object.assign(Object.assign({}, workflows[workflowIndex]), workflowUpdateBody), {\n          id // preserve id\n        });\n        // If direct request flag was provided, prioritize using the provided requestId\n        if (updateRequestFlag && providedRequestId) {\n          console.log('Direct request to update request ID:', providedRequestId);\n          const requestIndex = requests.findIndex(r => r.id === providedRequestId);\n          if (requestIndex !== -1) {\n            // Update request status based on workflow status\n            if (body.status === 'Approved') {\n              requests[requestIndex].status = 'Approved';\n              console.log('Updated request status to Approved');\n            } else if (body.status === 'Rejected') {\n              requests[requestIndex].status = 'Rejected';\n              console.log('Updated request status to Rejected');\n            } else if (body.status === 'Pending') {\n              requests[requestIndex].status = 'Pending';\n              console.log('Updated request status to Pending');\n            }\n          } else {\n            console.log('Request not found with ID:', providedRequestId);\n          }\n        }\n        // Otherwise, try to extract requestId from workflow details (for backward compatibility)\n        else if ((workflows[workflowIndex].type === 'Request Approval' || workflows[workflowIndex].type === 'RequestApproval' || workflows[workflowIndex].type.includes('Request')) && body.status && body.status !== oldStatus) {\n          // Try to extract requestId from details field\n          const detailsText = workflows[workflowIndex].details || '';\n          console.log('Workflow details text:', detailsText);\n          // Extract requestId - first try to parse as JSON\n          let requestId = null;\n          try {\n            // Try to parse details as JSON\n            if (typeof detailsText === 'string') {\n              if (detailsText.trim().startsWith('{')) {\n                const detailsObj = JSON.parse(detailsText);\n                if (detailsObj.requestId) {\n                  requestId = parseInt(detailsObj.requestId.toString());\n                  console.log('Extracted requestId from JSON:', requestId);\n                }\n              }\n            } else if (typeof detailsText === 'object') {\n              // It's already an object\n              const detailsObj = detailsText;\n              if (detailsObj && detailsObj.requestId) {\n                requestId = parseInt(detailsObj.requestId.toString());\n                console.log('Extracted requestId from object:', requestId);\n              }\n            }\n          } catch (e) {\n            console.log('Failed to parse details as JSON:', e);\n          }\n          // If JSON parsing failed, try regex patterns\n          if (!requestId && typeof detailsText === 'string') {\n            // Try matching standard format with HTML bold tags\n            const boldMatch = detailsText.match(/<b>requestId:<\\/b>\\s*(\\d+)/i);\n            if (boldMatch && boldMatch[1]) {\n              requestId = parseInt(boldMatch[1]);\n            }\n            // Try matching without HTML tags\n            if (!requestId) {\n              const plainMatch = detailsText.match(/requestId:\\s*(\\d+)/i);\n              if (plainMatch && plainMatch[1]) {\n                requestId = parseInt(plainMatch[1]);\n              }\n            }\n            // Try extracting from any #NUMBER pattern if nothing else worked\n            if (!requestId) {\n              const hashMatch = detailsText.match(/request\\s+#(\\d+)/i);\n              if (hashMatch && hashMatch[1]) {\n                requestId = parseInt(hashMatch[1]);\n              }\n            }\n          }\n          console.log('Final extracted requestId:', requestId);\n          if (requestId) {\n            const requestIndex = requests.findIndex(r => r.id === requestId);\n            if (requestIndex !== -1) {\n              console.log('Found request at index:', requestIndex);\n              // Update request status based on workflow status\n              if (body.status === 'Approved') {\n                requests[requestIndex].status = 'Approved';\n                console.log('Updated request status to Approved');\n              } else if (body.status === 'Rejected') {\n                requests[requestIndex].status = 'Rejected';\n                console.log('Updated request status to Rejected');\n              } else if (body.status === 'Pending') {\n                requests[requestIndex].status = 'Pending';\n                console.log('Updated request status to Pending');\n              }\n            } else {\n              console.log('Request not found with ID:', requestId);\n            }\n          } else {\n            console.log('Could not extract requestId from details:', detailsText);\n          }\n        }\n        return ok(workflows[workflowIndex]);\n      }\n      // Request route functions\n      function getRequests() {\n        // Get all requests with employee details\n        const allRequests = requests.map(request => {\n          // Find employee\n          const employee = employees.find(e => e.id === request.employeeId);\n          // Find user information if employee exists\n          let userEmail = 'Unknown';\n          let userRole = 'Unknown';\n          let user = null;\n          if (employee && employee.userId) {\n            user = accounts.find(a => a.id === employee.userId);\n            if (user) {\n              userEmail = user.email;\n              userRole = user.role;\n            }\n          }\n          // Find department information if employee exists\n          const department = (employee === null || employee === void 0 ? void 0 : employee.departmentId) ? departments.find(d => d.id === employee.departmentId) : null;\n          // Return enhanced request with employee and user info\n          // Ensure both items and requestItems properties exist for frontend compatibility\n          const enhancedRequest = Object.assign(Object.assign({}, request), {\n            Employee: employee ? Object.assign(Object.assign({}, employee), {\n              User: user ? {\n                id: user.id,\n                email: user.email,\n                role: user.role\n              } : null,\n              Department: department ? {\n                id: department.id,\n                name: department.name\n              } : null\n            }) : null,\n            userEmail,\n            userRole\n          });\n          // Ensure both items and requestItems are available\n          if (!enhancedRequest.items && enhancedRequest.requestItems) {\n            enhancedRequest.items = [...enhancedRequest.requestItems];\n          } else if (!enhancedRequest.requestItems && enhancedRequest.items) {\n            enhancedRequest.requestItems = [...enhancedRequest.items];\n          } else if (!enhancedRequest.items && !enhancedRequest.requestItems) {\n            // Initialize empty arrays for both if neither exists\n            enhancedRequest.items = [];\n            enhancedRequest.requestItems = [];\n          }\n          return enhancedRequest;\n        });\n        return ok(allRequests);\n      }\n      function getRequestById() {\n        const id = parseInt(path.split('/').pop());\n        const request = requests.find(r => r.id === id);\n        if (!request) return error('Request not found');\n        // Find employee\n        const employee = employees.find(e => e.id === request.employeeId);\n        // Find user information if employee exists\n        let userEmail = 'Unknown';\n        let userRole = 'Unknown';\n        let user = null;\n        if (employee && employee.userId) {\n          user = accounts.find(a => a.id === employee.userId);\n          if (user) {\n            userEmail = user.email;\n            userRole = user.role;\n          }\n        }\n        // Return request with user and employee info\n        const enhancedRequest = Object.assign(Object.assign({}, request), {\n          employee: employee ? {\n            id: employee.id,\n            employeeId: employee.employeeId\n          } : null,\n          Employee: employee ? Object.assign(Object.assign({}, employee), {\n            User: user ? {\n              id: user.id,\n              email: user.email,\n              role: user.role\n            } : null\n          }) : null,\n          userEmail,\n          userRole\n        });\n        // Ensure both items and requestItems are available\n        if (!enhancedRequest.items && enhancedRequest.requestItems) {\n          enhancedRequest.items = [...enhancedRequest.requestItems];\n        } else if (!enhancedRequest.requestItems && enhancedRequest.items) {\n          enhancedRequest.requestItems = [...enhancedRequest.items];\n        } else if (!enhancedRequest.items && !enhancedRequest.requestItems) {\n          // Initialize empty arrays for both if neither exists\n          enhancedRequest.items = [];\n          enhancedRequest.requestItems = [];\n        }\n        return ok(enhancedRequest);\n      }\n      function getRequestsByEmployeeId() {\n        const employeeIdParam = new URL(url).searchParams.get('employeeId');\n        if (!employeeIdParam) return error('Employee ID is required');\n        const employeeId = parseInt(employeeIdParam);\n        if (isNaN(employeeId)) return error('Invalid employee ID');\n        // Check if employee exists\n        const employee = employees.find(e => e.id === employeeId);\n        if (!employee) return error('Employee not found');\n        // Get user information\n        const user = accounts.find(a => a.id === employee.userId);\n        let userEmail = 'Unknown';\n        let userRole = 'Unknown';\n        if (user) {\n          userEmail = user.email;\n          userRole = user.role;\n        }\n        // Get department information\n        const department = departments.find(d => d.id === employee.departmentId);\n        // Filter requests by employee ID\n        const filteredRequests = requests.filter(r => r.employeeId === employeeId).map(request => {\n          const enhancedRequest = Object.assign(Object.assign({}, request), {\n            Employee: Object.assign(Object.assign({}, employee), {\n              User: user ? {\n                id: user.id,\n                email: user.email,\n                role: user.role\n              } : null,\n              Department: department ? {\n                id: department.id,\n                name: department.name\n              } : null\n            }),\n            userEmail,\n            userRole\n          });\n          // Ensure both items and requestItems are available\n          if (!enhancedRequest.items && enhancedRequest.requestItems) {\n            enhancedRequest.items = [...enhancedRequest.requestItems];\n          } else if (!enhancedRequest.requestItems && enhancedRequest.items) {\n            enhancedRequest.requestItems = [...enhancedRequest.items];\n          } else if (!enhancedRequest.items && !enhancedRequest.requestItems) {\n            // Initialize empty arrays for both if neither exists\n            enhancedRequest.items = [];\n            enhancedRequest.requestItems = [];\n          }\n          return enhancedRequest;\n        });\n        return ok(filteredRequests);\n      }\n      function createRequest() {\n        const account = currentAccount();\n        if (!account) return unauthorized();\n        // Use employeeId from body if provided (for admin users)\n        // Otherwise, find employee associated with current user\n        let employeeId;\n        if (body.employeeId && account.role === Role.Admin) {\n          // Admin users can create requests for any employee\n          employeeId = parseInt(body.employeeId);\n          // Verify that the employee exists\n          const employeeExists = employees.some(e => e.id === employeeId);\n          if (!employeeExists) {\n            return error('Selected employee not found');\n          }\n        } else {\n          // Regular users can only create requests for themselves\n          const employee = employees.find(e => e.userId === account.id);\n          if (!employee) {\n            return error('No employee record found for current user');\n          }\n          employeeId = employee.id;\n        }\n        // Find employee record for the request\n        const employee = employees.find(e => e.id === employeeId);\n        // Process items from either items or requestItems property\n        const requestItems = [];\n        if (body.items && Array.isArray(body.items)) {\n          body.items.forEach(item => {\n            requestItems.push({\n              name: item.name,\n              quantity: item.quantity || 1\n            });\n          });\n        } else if (body.requestItems && Array.isArray(body.requestItems)) {\n          body.requestItems.forEach(item => {\n            requestItems.push({\n              name: item.name,\n              quantity: item.quantity || 1\n            });\n          });\n        }\n        // Create request with proper structure\n        const request = {\n          id: requests.length + 1,\n          employeeId: employeeId,\n          type: body.type || 'Equipment',\n          status: 'Pending',\n          items: [...requestItems],\n          requestItems: [...requestItems] // For newer frontend implementations\n        };\n\n        console.log('Creating new request:', request);\n        requests.push(request);\n        // Create workflow entry for request approval\n        workflows.push({\n          id: workflows.length + 1,\n          employeeId: employeeId,\n          type: 'Request Approval',\n          details: JSON.stringify({\n            requestId: request.id,\n            requestType: request.type,\n            requesterId: employeeId,\n            message: `Review ${request.type} request #${request.id} from Employee ID ${employee.employeeId}.`\n          }),\n          status: 'Pending'\n        });\n        return ok(request);\n      }\n      function updateRequest() {\n        const id = parseInt(path.split('/').pop());\n        const reqIndex = requests.findIndex(r => r.id === id);\n        if (reqIndex === -1) return error('Request not found');\n        // Log incoming request update\n        console.log('Updating request:', id, 'with data:', body);\n        // Preserve the employeeId\n        const employeeId = requests[reqIndex].employeeId;\n        const oldStatus = requests[reqIndex].status;\n        // Process items from either items or requestItems property\n        const requestItems = [];\n        if (body.items && Array.isArray(body.items)) {\n          body.items.forEach(item => {\n            requestItems.push({\n              name: item.name,\n              quantity: item.quantity || 1\n            });\n          });\n        } else if (body.requestItems && Array.isArray(body.requestItems)) {\n          body.requestItems.forEach(item => {\n            requestItems.push({\n              name: item.name,\n              quantity: item.quantity || 1\n            });\n          });\n        } else {\n          // If no items provided, keep existing ones\n          requestItems.push(...(requests[reqIndex].requestItems || []));\n        }\n        // Update the request - prioritize any provided fields or keep the existing values\n        requests[reqIndex] = {\n          id,\n          employeeId,\n          type: body.type || requests[reqIndex].type,\n          status: body.status || requests[reqIndex].status,\n          items: [...requestItems],\n          requestItems: [...requestItems] // For newer frontend implementations\n        };\n\n        console.log('Request updated:', requests[reqIndex]);\n        // Find employee info for the workflow\n        const employee = employees.find(e => e.id === employeeId);\n        if (!employee) return error('Employee not found');\n        // Create workflow entry if status changed\n        if (body.status && body.status !== oldStatus) {\n          workflows.push({\n            id: workflows.length + 1,\n            employeeId: employeeId,\n            type: 'Request Status Updated',\n            details: JSON.stringify({\n              requestId: id,\n              requestType: requests[reqIndex].type,\n              requesterId: employeeId,\n              message: `${requests[reqIndex].type} request #${id} from Employee ID ${employee.employeeId} was ${body.status.toLowerCase()}.`\n            }),\n            status: 'Completed'\n          });\n        }\n        // Create workflow for request edits if items changed\n        else if (body.items || body.requestItems) {\n          workflows.push({\n            id: workflows.length + 1,\n            employeeId: employeeId,\n            type: 'Request Approval',\n            details: JSON.stringify({\n              requestId: id,\n              requestType: requests[reqIndex].type,\n              requesterId: employeeId,\n              message: `Review updated ${requests[reqIndex].type} request #${id} from Employee ID ${employee.employeeId}.`\n            }),\n            status: 'Pending'\n          });\n        }\n        return ok(requests[reqIndex]);\n      }\n      function getNextEmployeeId() {\n        console.log('Fake backend: Getting next employee ID');\n        // Find the highest employee ID number\n        let maxId = 0;\n        employees.forEach(emp => {\n          if (emp.employeeId && emp.employeeId.startsWith('EMP')) {\n            const idNum = parseInt(emp.employeeId.substring(3));\n            if (!isNaN(idNum) && idNum > maxId) {\n              maxId = idNum;\n            }\n          }\n        });\n        // Generate the next ID (current max + 1)\n        const nextId = maxId + 1;\n        const nextEmployeeId = 'EMP' + nextId.toString().padStart(3, '0');\n        console.log('Fake backend generated next employee ID:', nextEmployeeId);\n        return ok({\n          employeeId: nextEmployeeId\n        });\n      }\n      // Helper functions\n      function ok(body) {\n        return of(new HttpResponse({\n          status: 200,\n          body\n        }));\n      }\n      function error(message) {\n        return throwError(() => ({\n          error: {\n            message\n          }\n        }));\n      }\n      function unauthorized() {\n        return throwError(() => ({\n          status: 401,\n          error: {\n            message: 'Unauthorized'\n          }\n        }));\n      }\n      function forbidden() {\n        return throwError(() => ({\n          status: 403,\n          error: {\n            message: 'Forbidden'\n          }\n        }));\n      }\n      function basicDetails(account) {\n        const {\n          id,\n          title,\n          firstName,\n          lastName,\n          email,\n          role,\n          dateCreated,\n          isVerified,\n          status\n        } = account;\n        return {\n          id,\n          title,\n          firstName,\n          lastName,\n          email,\n          role,\n          dateCreated,\n          isVerified,\n          status\n        };\n      }\n      function isAuthenticated() {\n        return !!currentAccount();\n      }\n      function isAuthorized(role) {\n        const account = currentAccount();\n        if (!account) return false;\n        return account.role === role;\n      }\n      function idFromUrl() {\n        const urlParts = path.split('/');\n        return parseInt(urlParts[urlParts.length - 1]);\n      }\n      function newAccountId() {\n        return accounts.length ? Math.max(...accounts.map(x => x.id)) + 1 : 1;\n      }\n      function currentAccount() {\n        // check if jwt token is in auth header\n        const authHeader = headers.get('Authorization');\n        if (!authHeader || !authHeader.startsWith('Bearer fake-jwt-token')) return;\n        // check if token is expired\n        const jwtToken = JSON.parse(atob(authHeader.split('.')[1]));\n        const tokenExpired = Date.now() > jwtToken.exp * 1000;\n        if (tokenExpired) return;\n        const account = accounts.find(x => x.id === jwtToken.id);\n        return account;\n      }\n      function generateJwtToken(account) {\n        // create token that expires in 15 minutes\n        const tokenPayload = {\n          exp: Math.round(new Date(Date.now() + 15 * 60 * 1000).getTime() / 1000),\n          id: account.id\n        };\n        return `fake-jwt-token.${btoa(JSON.stringify(tokenPayload))}`;\n      }\n      function generateRefreshToken() {\n        const token = new Date().getTime().toString();\n        // add token cookie that expires in 7 days\n        const expires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toUTCString();\n        document.cookie = `fakeRefreshToken=${token}; expires=${expires}; path=/`;\n        return token;\n      }\n      function getRefreshToken() {\n        // get refresh token from cookie\n        return (document.cookie.split(';').find(x => x.includes('fakeRefreshToken')) || '=').split('=')[1];\n      }\n      function authorize(requiredRole, success) {\n        if (!isAuthenticated()) return unauthorized();\n        if (requiredRole && !isAuthorized(requiredRole)) return forbidden();\n        return success();\n      }\n    }\n  }\n  FakeBackendInterceptor.ɵfac = function FakeBackendInterceptor_Factory(t) {\n    return new (t || FakeBackendInterceptor)(i0.ɵɵinject(i1.AlertService));\n  };\n  FakeBackendInterceptor.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: FakeBackendInterceptor,\n    factory: FakeBackendInterceptor.ɵfac\n  });\n  return FakeBackendInterceptor;\n})();\nexport const fakeBackendProvider = {\n  provide: HTTP_INTERCEPTORS,\n  useClass: FakeBackendInterceptor,\n  multi: true\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}